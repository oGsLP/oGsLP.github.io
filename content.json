{"pages":[{"title":"分类","text":"","link":"/categories/index.html"}],"posts":[{"title":"ES6--模板字符串","text":"&emsp;软工三的时候大作业都采用了原生的一些方法，很多时候会碰到字符串里面引号错乱很头疼的时候，包括获得request的内容也是在jsp中嵌入java代码再转成js对象。j2ee的大作业接触了更多的技术后才发现嵌入代码或者数据的好处，例如jsp中使用el表达式，mustache语法在themeleaf和vue,angular等中的运用。其中还是js的es6新特性模板字符串让我最为欣赏。 模板字符串&emsp;其实原生的js里就有模板字符串的运用了，特别是在js操作新建dom的时候，例如123456$('#result').append( 'There are &lt;b&gt;' + basket.count + '&lt;/b&gt; ' + 'items in your basket, ' + '&lt;em&gt;' + basket.onSale + '&lt;/em&gt; are on sale!'); &emsp;这样的话要写很多的+和’’以及””,特别是嵌套的时候会出现各种复杂的问题，让人很难受，新的模板字符串特性使用反向引号和${}来完成字符串的拼接组成。12345$('#result').append(` There are &lt;b&gt;${basket.count}&lt;/b&gt; items in your basket, &lt;em&gt;${basket.onSale}&lt;/em&gt; are on sale!`); &emsp;少了很多引号和加号，瞬间会清爽很多吧。&emsp;写大作业的时候第一次了解到这个的时候瞬间有一种亲切感，那是因为不是第一次接触这个了，在自己学习perl的时候也碰到了几乎一样的定义，这比java繁琐的字符串操作要方便多了。有了这个，写大作业的时候可以说是游刃有余，特别在axios请求的url中需要一些动态生成的值，直接使用`/api/member/${member_id}`就行了。 其他&emsp;其实模板字符串并没有太多的内容，以上基本就是所有用法了，还有以下一些注意事项。 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。 大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性，而且还能调用函数(这点和vue使用的mustache语法很像) 如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。 模板字符串甚至还能嵌套。 1234567891011121314151617181920212223const tmpl = addrs =&gt; ` &lt;table&gt; ${addrs.map(addr =&gt; ` &lt;tr&gt;&lt;td&gt;${addr.first}&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;${addr.last}&lt;/td&gt;&lt;/tr&gt; `).join('')} &lt;/table&gt;`;const data = [ { first: '&lt;Jane&gt;', last: 'Bond' }, { first: 'Lars', last: '&lt;Croft&gt;' },];console.log(tmpl(data));// &lt;table&gt;//// &lt;tr&gt;&lt;td&gt;&lt;Jane&gt;&lt;/td&gt;&lt;/tr&gt;// &lt;tr&gt;&lt;td&gt;Bond&lt;/td&gt;&lt;/tr&gt;//// &lt;tr&gt;&lt;td&gt;Lars&lt;/td&gt;&lt;/tr&gt;// &lt;tr&gt;&lt;td&gt;&lt;Croft&gt;&lt;/td&gt;&lt;/tr&gt;//// &lt;/table&gt; 可以引用模板字符串本身执行 123456789// 写法一let str = 'return ' + '`Hello ${name}!`';let func = new Function('name', str);func('Jack') // \"Hello Jack!\"// 写法二let str = '(name) =&gt; `Hello ${name}!`';let func = eval.call(null, str);func('Jack') // \"Hello Jack!\" 应用&emsp;配合正则表达式等，模板字符串还有一些实用的技巧 摘自阮一峰老师的es6教程下面，我们来看一个通过模板字符串，生成正式模板的实例。 1234567let template = `&lt;ul&gt; &lt;% for(let i=0; i &lt; data.supplies.length; i++) { %&gt; &lt;li&gt;&lt;%= data.supplies[i] %&gt;&lt;/li&gt; &lt;% } %&gt;&lt;/ul&gt;`; 上面代码在模板字符串之中，放置了一个常规模板。该模板使用&lt;%...%&gt;放置 JavaScript 代码，使用&lt;%= ... %&gt;输出 JavaScript 表达式。 怎么编译这个模板字符串呢？ 一种思路是将其转换为 JavaScript 表达式字符串。 1234567echo('&lt;ul&gt;');for(let i=0; i &lt; data.supplies.length; i++) { echo('&lt;li&gt;'); echo(data.supplies[i]); echo('&lt;/li&gt;');};echo('&lt;/ul&gt;'); 这个转换使用正则表达式就行了。 12345678let evalExpr = /&lt;%=(.+?)%&gt;/g;let expr = /&lt;%([\\s\\S]+?)%&gt;/g;template = template .replace(evalExpr, '`); \\n echo( $1 ); \\n echo(`') .replace(expr, '`); \\n $1 \\n echo(`');template = 'echo(`' + template + '`);'; 然后，将template封装在一个函数里面返回，就可以了。 1234567891011121314let script =`(function parse(data){ let output = \"\"; function echo(html){ output += html; } ${ template } return output;})`;return script; 将上面的内容拼装成一个模板编译函数compile。 12345678910111213141516171819202122232425function compile(template){ const evalExpr = /&lt;%=(.+?)%&gt;/g; const expr = /&lt;%([\\s\\S]+?)%&gt;/g; template = template .replace(evalExpr, '`); \\n echo( $1 ); \\n echo(`') .replace(expr, '`); \\n $1 \\n echo(`'); template = 'echo(`' + template + '`);'; let script = `(function parse(data){ let output = \"\"; function echo(html){ output += html; } ${ template } return output; })`; return script;} compile函数的用法如下。 1234567let parse = eval(compile(template));div.innerHTML = parse({ supplies: [ \"broom\", \"mop\", \"cleaner\" ] });// &lt;ul&gt;// &lt;li&gt;broom&lt;/li&gt;// &lt;li&gt;mop&lt;/li&gt;// &lt;li&gt;cleaner&lt;/li&gt;// &lt;/ul&gt; 标签模板模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。 123alert`123`// 等同于alert(123) 标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。 但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。 123456let a = 5;let b = 10;tag`Hello ${ a + b } world ${ a * b }`;// 等同于tag(['Hello ', ' world ', ''], 15, 50); 上面代码中，模板字符串前面有一个标识名tag，它是一个函数。整个表达式的返回值，就是tag函数处理模板字符串后的返回值。 函数tag依次会接收到多个参数。 123456789function tag(stringArr, value1, value2){ // ...}// 等同于function tag(stringArr, ...values){ // ...} tag函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。 tag函数的其他参数，都是模板字符串各个变量被替换后的值。由于本例中，模板字符串含有两个变量，因此tag会接受到value1和value2两个参数。 tag函数所有参数的实际值如下。 第一个参数：['Hello ', ' world ', ''] 第二个参数: 15 第三个参数：50 也就是说，tag函数实际上以下面的形式调用。 1tag(['Hello ', ' world ', ''], 15, 50) 我们可以按照需要编写tag函数的代码。下面是tag函数的一种写法，以及运行结果。 1234567891011121314151617181920let a = 5;let b = 10;function tag(s, v1, v2) { console.log(s[0]); console.log(s[1]); console.log(s[2]); console.log(v1); console.log(v2); return \"OK\";}tag`Hello ${ a + b } world ${ a * b}`;// \"Hello \"// \" world \"// \"\"// 15// 50// \"OK\" 下面是一个更复杂的例子。 123456789101112131415161718let total = 30;let msg = passthru`The total is ${total} (${total*1.05} with tax)`;function passthru(literals) { let result = ''; let i = 0; while (i &lt; literals.length) { result += literals[i++]; if (i &lt; arguments.length) { result += arguments[i]; } } return result;}msg // \"The total is 30 (31.5 with tax)\" 上面这个例子展示了，如何将各个参数按照原来的位置拼合回去。 passthru函数采用 rest 参数的写法如下。 12345678910function passthru(literals, ...values) { let output = \"\"; let index; for (index = 0; index &lt; values.length; index++) { output += literals[index] + values[index]; } output += literals[index] return output;} “标签模板”的一个重要应用，就是过滤 HTML 字符串，防止用户输入恶意内容。 123456789101112131415161718let message = SaferHTML`&lt;p&gt;${sender} has sent you a message.&lt;/p&gt;`;function SaferHTML(templateData) { let s = templateData[0]; for (let i = 1; i &lt; arguments.length; i++) { let arg = String(arguments[i]); // Escape special characters in the substitution. s += arg.replace(/&amp;/g, \"&amp;amp;\") .replace(/&lt;/g, \"&amp;lt;\") .replace(/&gt;/g, \"&amp;gt;\"); // Don't escape special characters in the template. s += templateData[i]; } return s;} 上面代码中，sender变量往往是用户提供的，经过SaferHTML函数处理，里面的特殊字符都会被转义。 12345let sender = '&lt;script&gt;alert(\"abc\")&lt;/script&gt;'; // 恶意代码let message = SaferHTML`&lt;p&gt;${sender} has sent you a message.&lt;/p&gt;`;message// &lt;p&gt;&amp;lt;script&amp;gt;alert(\"abc\")&amp;lt;/script&amp;gt; has sent you a message.&lt;/p&gt; 标签模板的另一个应用，就是多语言转换（国际化处理）。 12i18n`Welcome to ${siteName}, you are visitor number ${visitorNumber}!`// \"欢迎访问xxx，您是第xxxx位访问者！\" 模板字符串本身并不能取代 Mustache 之类的模板库，因为没有条件判断和循环处理功能，但是通过标签函数，你可以自己添加这些功能。 123456789// 下面的hashTemplate函数// 是一个自定义的模板处理函数let libraryHtml = hashTemplate` &lt;ul&gt; #for book in ${myBooks} &lt;li&gt;&lt;i&gt;#{book.title}&lt;/i&gt; by #{book.author}&lt;/li&gt; #end &lt;/ul&gt;`; 除此之外，你甚至可以使用标签模板，在 JavaScript 语言之中嵌入其他语言。 123456789jsx` &lt;div&gt; &lt;input ref='input' onChange='${this.handleChange}' defaultValue='${this.state.value}' /&gt; ${this.state.value} &lt;/div&gt;` 上面的代码通过jsx函数，将一个 DOM 字符串转为 React 对象。你可以在 GitHub 找到jsx函数的具体实现。 下面则是一个假想的例子，通过java函数，在 JavaScript 代码之中运行 Java 代码。 12345678java`class HelloWorldApp { public static void main(String[] args) { System.out.println(\"Hello World!\"); // Display the string. }}`HelloWorldApp.main(); 模板处理函数的第一个参数（模板字符串数组），还有一个raw属性。 12console.log`123`// [\"123\", raw: Array[1]] 上面代码中，console.log接受的参数，实际上是一个数组。该数组有一个raw属性，保存的是转义后的原字符串。 请看下面的例子。 1234567tag`First line\\nSecond line`function tag(strings) { console.log(strings.raw[0]); // strings.raw[0] 为 \"First line\\\\nSecond line\" // 打印输出 \"First line\\nSecond line\"} 上面代码中，tag函数的第一个参数strings，有一个raw属性，也指向一个数组。该数组的成员与strings数组完全一致。比如，strings数组是[&quot;First line\\nSecond line&quot;]，那么strings.raw数组就是[&quot;First line\\\\nSecond line&quot;]。两者唯一的区别，就是字符串里面的斜杠都被转义了。比如，strings.raw 数组会将\\n视为\\\\和n两个字符，而不是换行符。这是为了方便取得转义之前的原始模板而设计的。","link":"/2019/03/24/template-string/"},{"title":"ES6--箭头函数","text":"&emsp;刚把jee的大作业写完，其中前端用到了Vue框架，在官方文档和很多教程里都使用了许多箭头函数等es6特性，加之昨天面试字节跳动前端实习的时候问道js的第一句话就是“你了解es2015”吗。写项目的时候模仿去写但是好像上下文this和普通的函数不太一样，后来查文档学习了一下，但还是没有全部理解，现在准备系统地学习一下es6的特性，那么就先从箭头函数开始吧 基本语法12345678910111213141516(aruguments) =&gt; {statements}x =&gt; x+2 // 单参省略括号，单语句且为返回值省略大括号()=&gt;{} // 无参保留()*********************************************//加括号的函数体返回对象字面表达式：参数=&gt; ({foo: bar})//支持剩余参数和默认参数(参数1, 参数2, ...rest) =&gt; {函数声明}(参数1 = 默认值1,参数2, …, 参数N = 默认值N) =&gt; {函数声明}//同样支持参数列表解构let f = ([a, b] = [1, 2], {x: c} = {x: a + b}) =&gt; a + b + c;f(); // 6 官网对与箭头函数的描述有两个特点，一个是更简短，另一个则是不绑定this，举例来说明123456function Test(){ this.val = 0; setInterval(function test(){ this.val++; },1000);} &emsp;因为setInterval中的function的this上下文是全局对象，所以test里的this.val和对象的val不一样，一般采用bind(this)或者self/that=this,在setInterval中调用that来获得对象上下文，而箭头函数则是不绑定this，具体原因是因为箭头函数没有prototype，它只会从自己的作用域链的上一层继承this上下文，如下123456function Test(){ this.val = 0; setInterval(()=&gt;{ this.val++; },1000);} &emsp;如果拿我自己的大作业的例子来说就是在尝试promise、then的时候发现this上下文的问题，一开始用bind来解决，后来接触箭头函数，就直接用箭头函数改写了方法，但是当时不知道箭头函数的this直接继承，后来发现，觉得真的很方便，简化了繁琐的bind，直接上实际例子。123456789101112131415161718192021222324252627282930//改造前pay_deal(){ new Promise(function (resolve) { // 略 resolve(val_1); }.bind(this)) .then(function (val_1){ return new Promise(function (resolve) { // 略 resolve(val_2); }.bind(this)); }.bind(this)) .then(function (val_2) { // 略 }.bind(this));},//改造后pay_deal(){ new Promise(resolve =&gt; { // 略 resolve(val_1) }); }).then(val_1=&gt;new Promise(resolve =&gt; { // 略 resolve(val_2) } })).then(val_2=&gt;{ // 略 });}, &emsp;效果很明显，省去了繁琐的this绑定，特别在promise的then连写的时候，return new promise需要两次绑定，简直就是灾难，用箭头函数瞬间清爽了很多。 FAQ &emsp; 若是箭头函数的外层没有普通函数呢？ 普通函数的默认绑定规则是，非严格模式下this指向全局，严格模式下为undefined 箭头函数在全局作用域下，严格模式与非严格模式下都会指向window(全局对象) 以上是箭头函数基本的两个概念，也是最简单的应用，还有很多实际的复杂情况和别的技术混合使用的例子 apply/call调用&emsp;由于箭头函数没有自己的this，通过apply或者call调用的时候只能传递参数，而第一个参数–上下文将被忽略，同样，箭头函数调用bind也是徒劳之举，webstorm会直接提醒错误 1234567891011121314151617181920var adder = { base : 1, add : function(a) { var f = v =&gt; v + this.base; return f(a); }, addThruCall: function(a) { var f = v =&gt; v + this.base; var b = { base : 2 }; return f.call(b, a); }};console.log(adder.add(1)); // 输出 2console.log(adder.addThruCall(1)); // 仍然输出 2（而不是3 ——译者注） 参数调用&emsp;箭头函数同样不绑定arguments参数，若是全局下的箭头函数，arguments指向全局，会出现arguments未声明的错误。而当箭头函数的this指向普通函数时，它的arguments同样继承自普通函数，这点还是很好理解的，也是可以利用这个特性去处理外层函数的不定参数。&emsp;但是如果需要获得箭头函数的不定量参数呢，没有了arguments怎么做？这就要用到es6的另一个特性，rest参数(…扩展符)。 1234567let fun = (x, ...args)=&gt;{ console.log(x); console.log(args);};fun(1,2,3);// 1// [2,3] &emsp;rest参数的详细会再出一个文章介绍，现在大致先了解一下，rest和arguments的区别在于rest是一个真正的数组，可以使用数组的api。rest在普通函数和箭头函数中都可以使用，但必须作为函数参数的最后一位，剩余参数嘛，字面意思也可以理解。 其他 箭头函数不能使用构造器，使用new会报错 箭头函数没有prototype new.target指向外层函数的引用 箭头函数不支持重命名函数参数，而不同函数的重复参数后面的会覆盖前面的 注意事项 一条语句返回对象字面量，需要加括号或者直接写成多条语句的return形式。说到这里我好像明白了vue的比较新的版本里data都是return一个对象了，而不是直接写，一个就是这个原因吧，可能vue的解析将其作为箭头函数了 12345data:{ return{ foo: bar }} 箭头函数的参数和箭头之间不能换行 123let fun = () =&gt; 1// 报错 箭头函数的解析顺序相对靠前，虽然箭头不是运算符，但是箭头函数具有与常规函数不同的特殊运算符优先级解析规则。 12let bool = false || ()=&gt;true;// 箭头函数先执行，false则因为懒惰机制不会参与计算 使用&emsp;箭头函数在一些简单的运算处理中是很方便简洁的，但是在复杂的逻辑以及多重嵌套里，因为上下文的确定有一定难度，造成代码可读性差。一句话来说就是，箭头函数更适合非方法的函数，或者本来就是需要作为匿名函数的地方，因为箭头函数也是匿名函数。 &emsp;关于箭头函数的使用仁者见仁，智者见智，箭头函数也是一把双刃剑，用在恰当的地方就像庖丁解牛一样游刃有余，滥用则会造成许多不必要的问题。如何使用的最佳实践，还是需要在代码中不断尝试才能知道。","link":"/2019/03/24/arrow-function/"},{"title":"一道linux管道题目来学习管道命令","text":"&emsp;寒假之前Linux程序设计这门课老师留了一道很有难度的shell cmd题目，大概要求用一行命令来完成对一个目录结构下的makefile文件全复制到另一个拥有相同目录结构的目录下，因为又不小的难度，所以可以用3行及以内linux命令来实现。肯定是要用管道的，但是当时自己对管道不是很熟悉，有点投机取巧用了偏方3行命令来写。期末复习的时候决定自己研究一下管道的知识。 &emsp; 首先，题目如下 &emsp;假设当前Linux系统的目录/tmp/gsl下的文件结构如下图所示，其中有很多Makefile分散在各个子目录下(但并非每个子目录都存在Makefile，例如block目录下就没有)。 &emsp;要求将这些Makefile拷贝到目录/home/usrname/gsl的对应子目录下(假设/home/usrname/gsl下已经存在blas，bspline等子目录)，使得拷贝后/home/usrname/gsl下的文件如下图所示： &emsp;要求：该要求实际上是可以用一行命令完成的，难度较高。同学们实际做作业时，允许使用两到三行命令，但不允许使用任何编程实现(即不允许Shell脚本的循环，分支等控制流程，可以使用管道)。&emsp;提示：利用find，sed和sh命令。 | 问题分析&emsp;题目要求在于整体的保持目录结构的前提下复制文件，首先想到的肯定是cp命令，先找到所有的Makefile文件，然后利用文件完整路径，使用sed的正则替换修改前缀，进行逐一复制，便可完成。但是想在一条命令里面就实现这项功能还是要用到管道的知识。 | 尝试管道的失败&emsp;思路本来是很清晰的 首先利用find 找到所有Makefile文件，而且这样的文件都是完整路径的，然后就使用sed替换, 最后cp, 但是由于管道的知识不熟悉，写出了以下的代码1find /tmp/gsl/ -name 'Makefile' | sed 's/^\\/tmp/\\/home\\/username/g' | cp &emsp;然后就下不下去了，cp两个参数该咋写啊。。而且这怎么保证是一条条执行的。&emsp;后来试了好多方法，不过好像都不太行，然后就有了以下的方法。 | 我的做法（投机取巧）123cd /tmpfind gsl/ -name &apos;Makefile&apos; | xargs tar -czf test.tar.gztar -zxvf test.tar.gz -C /home/usrname &emsp; 没错，我写了三条命令，不过这道题目能不用脚本写我觉得就很不错了23333&emsp; 这里使用了tar压缩解压文件的时间时候能够保留文件的目录结构，在这里压缩再到那里解压就行了，但是由于相对路径的问题，多写了一行cd，自己也没找到替代这行的办法。&emsp; 给很多同学看了这个方法，都觉得很有意思2333，的确有点不走寻常路的赶脚，但是问题还是要解决啊，这个毕竟没有用到老师教的知识。 | 正确做法1find /tmp/gsl/ -name &apos;Makefile&apos; | sed &apos;s/^\\/tmp\\(.*\\)/cp \\/tmp\\/gsl\\1 \\/home\\/username\\1/g&apos; | sh &emsp;当同学给我讲原理的时候我才发现我对管道的理解是完全错误的。。难怪写不出来，上面尝试的代码简直就是搞笑的哈哈哈。&emsp;这个解法技巧性的确很强，不得不说。简单说一下，第一步就是找到所有Makefile并获得完整路径，用管道传给sed，然后的意思呢，是指利用每个/tmp/gsl/…Makefile，sed替换出cp /tmp/gsl/…Makefile /home/username/…Makefile 这个命令，同学说，管道相当于把结果写入一个shell脚本，然后再传给sh命令去执行脚本就好了。的确很精妙，不过我有点怀疑，觉得管道并不是输出成脚本，我记得应该是把处处作为下一个的输入，就比如sed我不一定要把文件名做参数，字符串也行。&emsp;于是我决定一谈个究竟，管道究竟有什么奥妙之处 | 管道原理 &emsp; 管道是一种通信机制，通常用于进程间的通信（也可通过socket进行网络通信），它表现出来的形式将前面每一个进程的输出（stdout）直接作为下一个进程的输入（stdin）。 &emsp; 在linux命令中，能够使用管道的命令统称为管道命令，管道命令使用|作为界定符号,管道命令仅能处理standard output,对于standard error output会予以忽略。&emsp;less,more,head,tail…都是可以接受standard input的命令，所以他们是管道命令&emsp;ls,cp,mv并不会接受standard input的命令，所以他们就不是管道命令了。&emsp; 管道命令必须要能够接受来自前一个命令的数据成为standard input继续处理才行。 &emsp;现在再对上面的答案进行分析就很清晰了。同学说的当成写入文件在把文件作为参数其实是把标准输入输出说的复杂化了，虽然具象化了，但我们还是要对标准输入输出有所了解才行。 | 常见的管道命令 选取命令 cut grep 排序命令 sort,wc,uniq 双重定向命令 tee 字符转换命令 tr, col, join, paste, expand 切割命令 split sed, grep, awk, xargs, printf …… &emsp;这些分类并不是判断是否是管道命令的标准，更重要的还是根据一个命令的输入输出去判断，根据管道的定义去判断，灵活运用。 | xargs&emsp; 我在自己的方法里用的这个xargs其实也是管道命令的一种，它的作用可以说是比较有趣了。 &emsp; xargs 命令分别通过分割（-i）与分批（-n）行为产生某个命令的参数。接收stdin，以指定字符进行分隔，将stdin分成多个arguments&emsp;主要用于连接两个非管道命令 &emsp;通俗的将，xargs的作用就是将管道传来的标准输入分割成多个输入交由后面的命令依次执行。用在本题中好比我把好几个cp指令传过来，然后依次执行一个sh cp ...., 不用xargs的话就是相当于一次性包含多个cp命令的shell脚本交由sh去执行。&emsp;xargs还是有很大的用途的。 总结&emsp;小小的管道，如此奥妙。其实在很多的地方都有管道的应用，例如软件体系结构的管道过滤器风格，但是无论在哪里的应用，其原理都大差不离，真正弄懂管道的原理，一切与之有关的技术、难题也就都迎刃而解了。","link":"/2019/03/26/linux-pipe-commands/"},{"title":"人工智能、机器学习、深度学习三者","text":"借着期末复习（预习）体系结构这门课的契机，稍微了解了一点关于人工智能(Artificial Intelligence), 机器学习(Machine Learning), 深度学习(Deep Learning)的知识，之前对此还是完全不知所云的状态，现在决定初探其中的奥妙。首先，弄清楚这三者的关系。 &emsp;三者关系其实很简单，就如这张图所示，是一个包含关系，逐层深入。 人工智能&emsp;1956年，几个计算机科学家相聚在达特茅斯会议，提出了“人工智能”的概念，梦想着用当时刚刚出现的计算机来构造复杂的、拥有与人类智慧同样本质特性的机器。 &emsp;2012年以后，得益于数据量的上涨、运算力的提升和机器学习新算法（深度学习）的出现，人工智能开始大爆发。人工智能的研究领域也在不断扩大，人工智能研究的各个分支，包括专家系统、机器学习、进化计算、模糊逻辑、计算机视觉、自然语言处理、推荐系统等。可见机器学习只是人工智能的一部分，但也是最活跃的一部分。 &emsp;但目前的科研工作都集中在弱人工智能这部分，并很有希望在近期取得重大突破，电影里的人工智能多半都是在描绘强人工智能，而这部分在目前的现实世界里难以真正实现（通常将人工智能分为弱人工智能和强人工智能，前者让机器具备观察和感知的能力，可以做到一定程度的理解和推理，而强人工智能让机器获得自适应能力，解决一些之前没有遇到过的问题）。 &emsp;举个简单的例子吧，强智能就像守望先锋里面的智能机械，弱智能好比艾什的bob(hhh)。 机器学习&emsp;机器学习其实是一种实现人工智能的方法 &emsp; 机器学习最基本的做法，是使用算法来解析数据、从中学习，然后对真实世界中的事件做出决策和预测。 与传统的为解决特定任务、硬编码的软件程序不同，机器学习是用大量的数据来“训练”，通过各种算法从数据中学习如何完成任务。 &emsp;机器学习直接来源于早期的人工智能领域。传统算法包括决策树学习、推导逻辑规划、聚类、强化学习和贝叶斯网络等等。众所周知，我们还没有实现强人工智能。早期机器学习方法甚至都无法实现弱人工智能。 &emsp; 机器学习最成功的应用领域是计算机视觉， 虽然也还是需要大量的手工编码来完成工作。人们需要手工编写分类器、边缘检测滤波器，以便让程序能识别物体从哪里开始，到哪里结束；写形状检测程序来判断检测对象是不是有八条边；写分类器来识别字母“ST-O-P”。使用以上这些手工编写的分类器，人们总算可以开发算法来感知图像，判断图像是不是一个停止标志牌。 &emsp;这个结果还算不错，但并不是那种能让人为之一振的成功。特别是遇到云雾天，标志牌变得不是那么清晰可见，又或者被树遮挡一部分，算法就难以成功了。这就是为什么前一段时间，计算机视觉的性能一直无法接近到人的能力。它太僵化，太容易受环境条件的干扰。 &emsp;随着时间的推进，学习算法的发展改变了一切。 深度学习&emsp;人工神经网络（Artificial Neural Networks）是早期机器学习中的一个重要的算法，历经数十年风风雨雨。神经网络的原理是受我们大脑的生理结构——互相交叉相连的神经元启发。但与大脑中一个神经元可以连接一定距离内的任意神经元不同，人工神经网络具有离散的层、连接和数据传播的方向。 &emsp;例如，我们可以把一幅图像切分成图像块，输入到神经网络的第一层。在第一层的每一个神经元都把数据传递到第二层。第二层的神经元也是完成类似的工作，把数据传递到第三层，以此类推，直到最后一层，然后生成结果。 &emsp;每一个神经元都为它的输入分配权重，这个权重的正确与否与其执行的任务直接相关。最终的输出由这些权重加总来决定。 &emsp;我们仍以停止（Stop）标志牌为例。将一个停止标志牌图像的所有元素都打碎，然后用神经元进行“检查”：八边形的外形、救火车般的红颜色、鲜明突出的字母、交通标志的典型尺寸和静止不动运动特性等等。神经网络的任务就是给出结论，它到底是不是一个停止标志牌。神经网络会根据所有权重，给出一个经过深思熟虑的猜测——“概率向量”。 &emsp;这个例子里，系统可能会给出这样的结果：86%可能是一个停止标志牌；7%的可能是一个限速标志牌；5%的可能是一个风筝挂在树上等等。然后网络结构告知神经网络，它的结论是否正确。 &emsp;即使是这个例子，也算是比较超前了。直到前不久，神经网络也还是为人工智能圈所淡忘。其实在人工智能出现的早期，神经网络就已经存在了，但神经网络对于“智能”的贡献微乎其微。主要问题是，即使是最基本的神经网络，也需要大量的运算。神经网络算法的运算需求难以得到满足。 &emsp;不过，还是有一些虔诚的研究团队，以多伦多大学的Geoffrey Hinton为代表，坚持研究，实现了以超算为目标的并行算法的运行与概念证明。但也直到GPU得到广泛应用，这些努力才见到成效。 &emsp;我们回过头来看这个停止标志识别的例子。神经网络是调制、训练出来的，时不时还是很容易出错的。它最需要的，就是训练。需要成百上千甚至几百万张图像来训练，直到神经元的输入的权值都被调制得十分精确，无论是否有雾，晴天还是雨天，每次都能得到正确的结果。 &emsp;只有这个时候，我们才可以说神经网络成功地自学习到一个停止标志的样子；或者在Facebook的应用里，神经网络自学习了你妈妈的脸；又或者是2012年吴恩达（Andrew Ng）教授在Google实现了神经网络学习到猫的样子等等。 &emsp;吴教授的突破在于，把这些神经网络从基础上显著地增大了。层数非常多，神经元也非常多，然后给系统输入海量的数据，来训练网络。在吴教授这里，数据是一千万YouTube视频中的图像。吴教授为深度学习（deep learning）加入了“深度”（deep）。这里的“深度”就是说神经网络中众多的层。 &emsp;现在，经过深度学习训练的图像识别，在一些场景中甚至可以比人做得更好：从识别猫，到辨别血液中癌症的早期成分，到识别核磁共振成像中的肿瘤。Google的AlphaGo先是学会了如何下围棋，然后与它自己下棋训练。它训练自己神经网络的方法，就是不断地与自己下棋，反复地下，永不停歇。 &emsp;深度学习，给人工智能以璀璨的未来。&emsp;深度学习使得机器学习能够实现众多的应用，并拓展了人工智能的领域范围。深度学习摧枯拉朽般地实现了各种任务，使得似乎所有的机器辅助功能都变为可能。无人驾驶汽车，预防性医疗保健，甚至是更好的电影推荐，都近在眼前，或者即将实现。 &emsp;转载: https://www.cnblogs.com/dadadechengzi/articles/6575767.html &emsp;最后期待一下deepmind战胜星际争霸2的世界冠军的那一天究竟什么时候能够到来，serral也好，Innovation也好。","link":"/2019/03/25/ai-ml-dl/"},{"title":"字节跳动暑期前端实习笔试 + 一面","text":"上周抱着试一试的心理去参加了班群里内推的字节跳动的暑期前端实习，笔试是在牛客网上做四道算法题，2个小时，前两题很简单做了30分钟就跑过了，后两道题难度有点大，我又是算法没怎么做过，所以光靠脑子还是有点招架不住。不知道是报的前端的原因还是后面两道的确难，也是拿到了面试资格，今天下午3点去试了一下，也是自己第一次求职面试。之前一直在赶大作业，所以就昨天晚上今天早上各两三个小时准备了一点，虽然面试题目其实不是很难但是还是倒了，而且是刚结束一分钟就收到短信说你凉了。。。分享一下，菜勿喷。 笔试 1024元的钞票买n ([0-1024]) 元的商品，共有64,16,4,1这四种硬币，问最少能找零几个硬币。 + 硬币币值差4倍相当于&gt;&gt;2，用移位来做 字符串问题，碰到aabb简化为aab，aaa简化为aa + charAt遍历，分情况讨论，每次简化时记得字符串长度会变 一个数组int[n]代表n个人的分数，n个人围成环，给他们发奖品，每个人至少一个，如果比左右分高，那么奖品也要比左右多，问最少发多少奖品，其中存在 1,2,3,3发奖品为1,2,3,2的情况 + 据说是动态规划的题目，自己不是很了解，记得填坑 一个数组int[n]代表n个绳子的长度，然后告诉你需要的绳子个数num，剪绳子但不能拼接，要求剪出来的绳子长度一样，其中num可能大于或等于或小于n，求剪出来的绳子最长长度是多少（保留2位小数）。 + 一开始当做数学提来写的，但是分情况很细的时候发现不太好讨论了，比如1,1,1,1,100要10根，我更本就不用考虑长度为1的，100分成10*10就完事了。其实可能还是要分解问题去做。。待填坑 我觉得无论如何前两题都得做出来，后两题真的需要大量的练习才能了解解题的技巧，光靠脑子是不行的，还是得加油啊 面试 平时以为自己前端写的还可以，面试问题就全暴露出来了，一堆基础知识掌握不牢，光靠临时抱佛脚还是不行的，js博大精深hhh，还是把我记得的都说出来看看 自我介绍一分钟左右，按照网上说的来历学历项目经验说一说吧，感觉他只对你的项目经验有一点兴趣。 html h5新特性（新标签）=&gt; 新标签的作用用法 css display,position的种类 =&gt; absolute,float导致的流出现覆盖的消除方法 一个定宽高以及不定宽高的块级元素水平居中的方法（margin auto left/right 0 ,flex等） 选择器的优先级 js 一上来问熟悉不熟悉 es2015 基本类型: boolean,string,number,undefined,null。 “还有?” ？？？？ “es15还有symbol” —es15还是很多东西不会的啊 编程题 找出字符串中出现最多的字母以及次数，我的天我居然忘了hash，用数组了。。。。 读程序输出题 我是真的懵逼了。。原型我是真的不会prototype1234567891011121314151617181920212223242526272829var A = function () { function B () { console.log(1); } return this;};A.B=function () { console.log(2);};A.prototype.B=function () { console.log(3);};var B = function () { console.log(4);};B = function () { console.log(5);};A().B;B();A.B();B();new A.B();new A().B(); is not a function;5;2;5;2;3 这题不会真的是js的基本功不行。。加上紧张诶，还是得回去还好练练 读程序setTimeOut123456for(var i = 0 ; i&lt;5 ;i++){ setTimeout(function () { console.log(i); });}console.log(i); 好不容易看到会的了，我一激动说成了一个0五个5，其实后来仔细一看是六个5。。。。 还问了怎么改，这个是会的，let、闭包立即函数 我只是个前端啊，没想到还问数据结构与算法。。。那些我学的都不行啊。。。 算法 冒泡排序bubbleSort123456789101112function bubbleSort(arr){ for(let i=0;i&lt;arr.length-1;i++){ for(let j=0;j&lt;arr.length-1-i;j++){ if(arr[j]&gt;arr[j+1]){ let temp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; } } } return arr;} 快速排序quickSort12345678910111213141516function quickSort(arr){ if(arr.length&lt;=1){return arr;} let pivotIndex=Math.floor(arr.length/2); let pivot=arr.splice(pivotIndex,1)[0]; let left=[]; let right=[]; for(let i=0;i&lt;arr.length;i++){ if(arr[i]&lt;=pivot){ left.push(arr[i]); } else{ right.push(arr[i]); } } return quickSort(left).concat([pivot],quickSort(right));} 这两个特地看了一下，还是会的 数据结构 二叉树我把前中后的顺序记错了。。面试官告诉我顺序还是能弄出来的 队列和栈的区别 我瞎答得，我记得队列先进先出，栈是先进后出 计算机网络 tcp、udp区别 三次握手，四次挥手 1-5的状态码。。细的我记不太清楚了 FAQ最后让我问他一些问题，我其实也没啥好问的，就问了这个工作的一些内容，草草收场了 最后 面试完如释重负，瞬间轻松好多，刚和舍友吐槽一下，叮~，一条短信，“经过慎重考虑，很遗憾你未通过此次面试，如果。。。。。。。。。。。。。。。。。。。。。。。。。。” 加油吧，学习吧，面试什么的下次再战！","link":"/2019/03/23/interview/"},{"title":"Html meta属性总结","text":"&emsp; Html写了也不少了，但是每次都是光顾着写页面的展示元素了，一直都忽略了head标签里的meta属性，讲道理自己除了复制粘贴的一些从来没自己写过meta属性的东西，现在借此文好好学习一下 meta定义 &emsp; The &lt;meta> tag provides metadata about the HTML document. Metadata will not be displayed on the page, but will be machine parsable.&emsp; metadata，中文名叫元数据，是用于描述数据的数据。它不会显示在页面上，但是机器却可以识别 &emsp; Meta elements are typically used to specify page description, keywords, author of the document, last modified, and other metadata.&emsp; meta常用于定义页面的说明，关键字，最后修改日期，和其它的元数据。这些元数据将服务于浏览器（如何布局或重载页面），搜索引擎和其它网络服务。 用法meta包括几个属性：content、http-equiv、name、scheme，其中content是必须的，其他三个可选。 #contentcontent属性提供了名称/值对中的值，可以是任意字符串。content始终要和name、http-equiv一起使用 #http-equiv与content组成键值对，成为http的头文件的参数对1&lt;meta http-equiv=\"xxx\" content=\"xxx\"/&gt; 其中参数有下列常见的几种 content-Type 设定网页字符集 12&lt;meta http-equiv=\"content-Type\" content=\"text/html;charset=utf-8\"&gt; //旧的HTML，不推荐&lt;meta charset=\"utf-8\"&gt; //HTML5设定网页字符集的方式，推荐使用UTF-8 X-UA-Compatible 浏览器采取何种版本渲染当前页面 1&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"/&gt; //指定IE和Chrome使用最新版本渲染当前页面 cache-control 指定请求和响应遵循的缓存机制 指导浏览器如何缓存某个响应以及缓存多长时间。 no-cache: 先发送请求，与服务器确认该资源是否被更改，如果未被更改，则使用缓存。 no-store: 不允许缓存，每次都要去服务器上，下载完整的响应。（安全措施） public : 缓存所有响应，但并非必须。因为max-age也可以做到相同效果 private : 只为单个用户缓存，因此不允许任何中继进行缓存。（比如说CDN就不允许缓存private的响应） maxage : 表示当前请求开始，该响应在多久内能被缓存和重用，而不去服务器重新请求。例如：max-age=60表示响应可以再缓存和重用 60 秒。 用于禁止当前页面在移动端浏览时，被百度自动转码。1&lt;meta http-equiv=\"Cache-Control\" content=\"no-siteapp\" /&gt; expires 网页到期时间。用于设定网页的到期时间，过期后网页必须到服务器上重新传输。 1&lt;meta http-equiv=\"expires\" content=\"Sunday 26 October 2016 01:00 GMT\" /&gt; refresh 自动刷新并指向某页面。网页将在设定的时间内，自动刷新并调向设定的网址。 1&lt;meta http-equiv=\"refresh\" content=\"2；URL=http://oGsLP.github.io/\"&gt; //意思是2秒后跳转向我的博客 Set-Cookie cookie设定。如果网页过期。那么这个网页存在本地的cookies也会被自动删除。 12&lt;meta http-equiv=\"Set-Cookie\" content=\"name, date\"&gt; //格式&lt;meta http-equiv=\"Set-Cookie\" content=\"User=Lxxyx; path=/; expires=Sunday, 10-Jan-16 10:00:00 GMT\"&gt; //具体范例 #namename属性主要用于描述网页，比如网页的关键词，叙述等。与之对应的属性值为content，content中的内容是对name填入类型的具体描述，便于搜索引擎抓取。1&lt;meta name=\"xxx\" content=\"xxx\"/&gt; 其中参数有下列常见的几种 keywords 关键字。用来告诉搜索引擎网页的关键字 1&lt;meta name=\"keywords\" content=\"html,js,css\"&gt; description 描述。告诉搜索引擎网站的主要内容 1&lt;meta name=\"description\" content=\"html meta's role\"&gt; viewport 移动端窗口 1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; 详细关于viewport robots 定义搜索引擎爬虫机器人的索引方式 none : 搜索引擎将忽略此网页，等价于noindex，nofollow。 noindex : 搜索引擎不索引此网页。 nofollow: 搜索引擎不继续通过此网页的链接索引搜索其它的网页。 all : 搜索引擎将索引此网页与继续通过此网页的链接索引，等价于index，follow。 index : 搜索引擎索引此网页。 follow : 搜索引擎继续通过此网页的链接索引搜索其它的网页。 author 标注网页作者 generator 标注网站编写工具 copyright 标注版权信息 revisit-after 搜索引擎爬虫重访时间。如果页面不是经常更新，为了减轻搜索引擎爬虫对服务器带来的压力，可以设置一个爬虫的重访时间。如果重访时间过短，爬虫将按它们定义的默认时间来访问。 1&lt;meta name=\"revisit-after\" content=\"7 days\" &gt; enderer 双核浏览器渲染方式。renderer是为双核浏览器准备的，用于指定双核浏览器默认以何种方式渲染页面。 123&lt;meta name=\"renderer\" content=\"webkit\"&gt; //默认webkit内核&lt;meta name=\"renderer\" content=\"ie-comp\"&gt; //默认IE兼容模式&lt;meta name=\"renderer\" content=\"ie-stand\"&gt; //默认IE标准模式","link":"/2019/04/15/html-meta/"},{"title":"Html基础补盲","text":"关于前端的html基础知识的补盲，和一些重要知识。何谓补盲,就是那些容易被忽略的，多数情况下采用默认的一些设置等等。 HtmlHypertext markup language, 超文本标记语言知道html的详细名称，怎么能不知道超文本和markup的意思呢？&emsp;hypertext: 超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本&emsp;markup与markdown: 博客就是用markdown语言写的，然后转成了markup标记语言html呈现在浏览器中的。标记语言的意思，即在文本中加入一些说明符号来指示排版要求；Markdown 就是一种轻量级的标记语言（a lightweight Markup language). 他更简单，语法很简洁，易于学习。 Markdown 就是一种markup language，一种简单易用的排版语法。 #htm,html,xhtml,xml xml与别的三个本质上不一样，xml是可扩展标记语言，他的目的在于数据的传输 html与htm没有本质上的区别，只是Windows和UNIX对抗的产物。 DOS仅能识别8+3的文件名，所以.htm的命名方法可以被DOS识别，而.html的文件命名方式不能被之识别。 在UNIX系统中，网页必须使用.html扩展名，如果是htm，在浏览器中打开时则出现源代码；Windows中支持两种扩展名。 xhtml是用xml格式编写的html，体现在编写的格式更加严格 文档结构 XHTML DOCTYPE 是强制性的 &lt;html> 中的 XML namespace 属性是强制性的 &lt;html>、&lt;head>、&lt;title> 以及 &lt;body> 也是强制性的 元素语法 元素必须正确嵌套 元素必须始终关闭 元素必须小写 文档必须有一个根元素 属性语法 属性必须使用小写 属性值必须用引号包围 属性最小化也是禁止的 #head我们往往专注于body中的标签布局等代码的编写却忽略跳过了head标签的一些属性 title: title定义了html的标题，是必须的属性 定义了浏览器工具栏的标题 网页被添加至收藏夹中的标题 显示在搜索引擎结果页面的标题 base: 标签描述了基本的链接地址/链接目标，该标签作为HTML文档中所有的链接标签的默认链接 meta: 标签提供了元数据.元数据也不显示在页面上，但会被浏览器解析。 通常用于指定网页的描述，关键词，文件的最后修改时间，作者，和其他元数据。 元数据可以使用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他Web服务 1234&lt;meta name=\"keywords\" content=\"HTML, CSS, JavaScript\"&gt;&lt;meta name=\"description\" content=\"Html base\"&gt;&lt;meta name=\"author\" content=\"oGsLP\"&gt;&lt;meta http-equiv=\"refresh\" content=\"30\"&gt; // 每30s刷新界面 meta详细知识 style,script,link不做赘述 #内联与外引、嵌入 主要针对js与css，内联即在html中使用style和script标签，嵌入则直接在标签中使用style和监听事件的js，外引则使用import或者head中的link、script等方式引用外部资源。 内联的好处在于，有效减少 HTTP 请求，提升页面性能，缓解服务器压力。浏览器加载完才能渲染页面。但是维护不方便，代码复用不方便。 外引的好处是html,js,css职责分离，减少耦合，便于维护，但是会增大http请求。 嵌入实质上是一种侵入式js/css，除非一些特殊的情况不推荐使用，例如特定的功能等。 #块级元素与行内（内联）元素 块级元素 总是在新行上开始 高度，行高以及外边距和内边距都可控制 宽度缺省是它的容器的100% 块级元素可以容纳行内元素或者其他块级元素 行内元素 和其他元素都在一行上 高，行高以及外边距和内边距不可改变 宽度就是它的文字或者图片的宽度，不可改变 内联元素只能容纳文本或者其他内联元素 对于行内元素: 设置宽度width无效 设置高度height无效，可以通过line-height来设置 设置margin、padding只有左右有效 通过display属性可以对行内元素和块级元素进行切换（inline,block,inline-block） 块级元素address, article, aside, audio, blockquote, canvas, caption, dd, div, dl, dt, details, fieldset, figcaption, figure, footer, form, h*, header, hr, legend, li, menu, meter, nav, noframes, noscript, ol, output, p, pre, section, table, tbody, td, tfoot, th, thead, time, tr, ul 行内元素a, abbr, acronym, b, bdo, big, br, button, cite, code, command, dfn, del, em, embed, i, img, input, kbd, label, map, mark, objec, progress, q, samp, select, small, span, strong, sub, sup, textarea, time, tt, var, video, wbr #html语义化&emsp;&emsp;HTML语义化是指仅仅从 HTML 元素上就能看出页面的大致结构，比如需要强调的内容可以放在&lt;strong>标签中，而不是通过样式设置&lt;span>标签去做。不同浏览器对 HTML 元素的解析可能有差异，HTML 语义化便是在抛开样式之后，页面能有一个友好的展示效果。我们力求让页面有良好的结构，让页面的元素有含义，同时利于被搜索引擎解析，利于 SEO。HTML 语义化的建议 少使用无意义的&lt;div>、&lt;span> 标签； 在&lt;label> 标签中设置 for 属性和对应的&lt;input>关联起来； 设置&lt;img> 标签的 alt 属性，给&lt;a>标签设置 title 属性，利于 SEO； 在页面的标题部分使用&lt;h1>~&lt;h6>标签，不需要给它们加多余的样式； 与表单、有序列表、无序列表相关的标签不要单独使用。 HTML5 也新增了一些语义化的元素，我们通过标签名就能判断标签内容。使用语义元素的页面大致结构如下 #Html全局属性 属性 描述 是否H5新增 accesskey 设置访问元素的键盘快捷键。 class 元素的类名 contenteditable 规定是否可编辑元素内容 + contextmenu 指定元素的上下文菜单 + data-* 用于嵌入自定义数据 + dir 规定文本的排列方向 ltr/rtr/auto draggable 元素能否拖动 + dropzone 指定是否将数据复制，移动，或链接 copy/move/link + hidden 隐藏元素但要渲染 + id id lang 语言代码 spellcheck 检测元素是否拼写错误 + - style 元素行内样式 tabindex 带有指定的 tab 键导航顺序的链接 title 规定元素的额外信息（可在工具提示中显示） translate 指定是否一个元素的值在页面载入时是否需要翻译 + - #事件窗口事件属性（Window Event Attributes）由窗口触发该事件 (适用于 &lt;body> 标签): onafterprint, onbeforeprint, onload, onbeforeunload, onunload onerror, onoffline, ononline onhaschange, onmessage, onblur, onfocus onpagehide, onpageshow, onpopstate onredo, onresize, onstorage, onundo 表单事件 (Form Events)适用于所有html元素，但该元素必须在form表单内 onblur, onchange, oncontextmenu, onfocus onformchange, onforminput, oninput oninvalid, onreset, onselect, onsubmit 键盘事件 (Keyboard Events) onkeydown, onkeypress, onkeyup 鼠标事件 (Mouse Events) onclick, ondbclick ondrag, ondragend, ondragenter, ondragleave, ondragover, ondragstart, ondrop onmousedown, onmouseout, onmouseover, onmouseup, onmousewheel, onscroll 多媒体事件 (Media Events) 暂不做了解 #其他 iframe: src属性导向另一个网页","link":"/2019/04/15/html-base/"},{"title":"npm package 学习（一） -- commander.js","text":"&emsp;commander.js 学习 commander.js 当前版本2.20 @tj github,文档 用途：nodejs的cli tool编写框架 示例12345678910111213141516171819202122232425262728293031323334353637383940var program = require('commander');program .version('0.1.0') .option('-C, --chdir &lt;path&gt;', 'change the working directory') .option('-c, --config &lt;path&gt;', 'set config path. defaults to ./deploy.conf') .option('-T, --no-tests', 'ignore test hook');program .command('setup [env]') .description('run setup commands for all envs') .option(\"-s, --setup_mode [mode]\", \"Which setup mode to use\") .action(function(env, options){ var mode = options.setup_mode || \"normal\"; env = env || 'all'; console.log('setup for %s env(s) with %s mode', env, mode); });program .command('exec &lt;cmd&gt;') .alias('ex') .description('execute the given remote cmd') .option(\"-e, --exec_mode &lt;mode&gt;\", \"Which exec mode to use\") .action(function(cmd, options){ console.log('exec \"%s\" using %s mode', cmd, options.exec_mode); }).on('--help', function() { console.log(''); console.log('Examples:'); console.log(''); console.log(' $ deploy exec sequential'); console.log(' $ deploy exec async'); });program .command('*') .action(function(env){ console.log('deploying \"%s\"', env); });program.parse(process.argv); 步骤 #!/usr/bin/env node 创建cli的program变量 commader exports了一个全局对象，适用于快速开发。同样exports了对象，通过new一个实例作为局部变量，应用于复杂应用。 12345678// global objectconst program = require(\"commander\");program.version(\"0.0.1\");// local objectconst commander = require(\"commander\");program = new commander.Command();program.version(\"0.0.1\"); 配置program及option 配置program的命令及option parse 解析argv、设置的选项、激发的命令 必要的program.parse(process.argv); 组成 return {Command} for chaining Command对象源码 12345678function Command(name) { this.commands = []; this.options = []; this._execs = {}; this._allowUnknownOption = false; this._args = []; this._name = name || ''; } command Command.prototype.command(name, desc, opts) 创建cli的命令 当name通过ARGV被识别，剩余的参数用于访问函数，并且引发action回调函数 当name是*时，会处理所有未匹配的命令，参数从第二个算起 name格式：’name [args…]’ 可以且只有最后一个参数可以是可变参数，且要用… &lt;&gt;代表必需参数，[]为可选参数 Command.prototype.arguments() 指定参数的格式 Command.prototype.parseExpectedArgs() 解析command name中的参数 Git-style sub-commands 123456789// file: ./examples/pmvar program = require('commander');program.version('0.1.0').command('install [name]', 'install one or more packages').command('search [query]', 'search with optional query').command('list', 'list packages installed', {isDefault: true}).parse(process.argv); 当command()的调用方法参数中含有descr时，action方法不该调用，而是交给入口文件的的目录的可执行文件执行(pm-install, pm-search) option Option对象源码 12345678910function Option(flags, description) { this.flags = flags; this.required = ~flags.indexOf('&lt;'); this.optional = ~flags.indexOf('['); this.bool = !~flags.indexOf('-no-'); flags = flags.split(/[ ,|]+/); if (flags.length &gt; 1 &amp;&amp; !/^[[&lt;]/.test(flags[1])) this.short = flags.shift(); this.long = flags.shift(); this.description = description || ''; } Command.prototype.option(flags, description, fn ,defaultValue) flags: ‘-f, –flag /[opt]’ no-前缀会让值默认为true, 而调用时会为false [opt] @private Option.prototype.attributeName() 选项的长名字的驼峰命名 Command.prototype.allowUnknownoption(arg) 允许未知的选项出现在命令行 description/alias/version 设置description、alias、version action 注册命令的回调处理函数 […cmd] parse Command.prototype.parse(argv) 解析argv Command.prototype.parseOptions(argv) 返回argv的列表 其余api Command.prototype.opts() 返回一个包含options的键值对的对象 Command.prototype.name(str|) 设置/获取command的名字 Command.prototype.usage(str|) 设置/获取命令的用法([command][options] …) Command.prototype.outputHelp(callback) 打印命令的帮助信息 Command.prototype.help(callback) 打印帮助信息并退出 program.on(flag,func) 监听","link":"/2019/07/19/commander-js/"},{"title":"6.19的随记","text":"&emsp; 大三也快结束了，10天之后就要开始期末考试，虽然还有一堆作业没有完成，但还是想总结一下这个复杂的学期。 &emsp; 其实得从去年这个时候开始讲起。。。。 一年前&emsp;&emsp;好吧，先从16年入学说吧。由于大学之前没有任何编程的基础，加上这个专业本非我愿，而是在父母的要求下才选择的，一直以来都对这方面比较排斥也一直提不起兴趣来。整个大一的课程有一半是数学，而且专业课很多都是偏理论的，加上自己有一点小聪明，所以没有看出来和别人的差距。大二的话自己沉迷游戏不学习，而且作为社团的社长也很忙碌，两个学期也没怎么学，第一学期的软工大作业是真的被队友逼出来的，那是一个javafx为前端的大作业，那也是自己第一次接触可视化的编程。&emsp;&emsp;然后就是大二下的软工三，这次换了一批队友，工作量也大幅上升，由于自己错误的认为自己写过前端就选择了前端工作，自此算是走上了前端的不归路。html/css/js现学手写，也算是交出一套能看的界面，虽然还是很丑。因为之前的知识欠缺，自己还是花了相当的功夫的。还记得那时候每天去汉风堂早上待到晚上，一像素一像素去修改样式，一行行去读懂网上的组件代码。那时候很多写前端的不谈jquery了，连angular/react/vue什么的都运用在项目里了，自己连原生的ajax请求都写不会。&emsp;&emsp;然后是那个暑假，那个完全荒废的暑假，自己真的两个月什么事也没干，真正的一事无成，玩也没玩开心，学也啥都没学，就这样带着贫瘠的知识去迎接大三生活 大三上&emsp;&emsp;大学养成的不听课的习惯早已渗透进我的认知，尽管大三三个学期，课还巨多。 这个时候的我，可以说除了一点简单的算法题目，写几个静态界面，没有任何的代码能力。 上学期构造课让做了个画板，也是抄抄改改用javafx搞出来的，可笑的是就这么一个作业我居然第一次自己去使用java类的封装和继承。。。其实还是要感谢大三上的这些课，让我有机会第一次了解到了本该大一大二就掌握的东西。&emsp;&emsp;重点的话还是web这门课吧，跟着教材自己码了一遍代码，讲道理从node开始自己就有点蒙了，那完全是未知领域，还记得大二的软工三还去弄了一天，结果啥也没搞得懂就放弃了。然后以为作业也就是写写界面什么的，然而后来老师突然提速，cookie/session, 连数据库，ajax, 图片的编辑合成，最后改成标签化应用。。。现在看来其实没那么恐怖，但对当时的我来说，express/node/npm/callback都是未知领域，那时的我对回调这个东西就是束手无策，完全不知道怎么解决。说实话那门课让我真的很不好过，最后混了一个交上去，最后一个作业也没完成。后来期末复习的时候背复习提纲的时候也算让我对前端有了一个较为完整的认识，远远不止所谓的静态页面这么简单。&emsp;&emsp;这门课的刘老师，我很不喜欢他2333，但还是很感谢他将我带入门。&emsp;&emsp;这学期可以说是大学里一个转折点吧，搬到鼓楼校区少了很多外界的干扰，这个学期自己在不断调整状态，开始去找学习的感觉。（PS: 这学期看了不少电影。。基本一周一部） 大三中&emsp;&emsp;很快的，12月就开始第二个学期，这学期课程较少，只有一门j2ee和一节必修体系结构和一节专业选修linux程序设计，另有一门只去过一次的水课。j2ee就是javaweb的工程化的科目，这门课自己还是有在好好学的，每次作业认真去做，包括认真完成的大作业。体系结构则是让我了解了一点深度学习（喵喵喵？），linux的话还是加强了自己一点基础知识的。&emsp;&emsp;当然最主要的还是j2ee，首先感谢王浩然老师吧，虽然在大一的计基给我留下了学习这门专业的阴影。这学期寒假前后各一个半月，前半个月基本上都在肝这门课的平时作业，也就是8次作业吧，我还是学到了很多，让我第一次去接触去写后端java，更好的去了解了一些面向对象，还有hibernate/spring等框架，看着自己手写出来的这些代码，还是很欣慰的，放在再往前是完全不敢想象的。&emsp;&emsp;最大的挑战还是大作业，真的很庆幸当时的自己鼓起来勇气选择挑战自己，选择了Spring boot/MyBatis/Vue 的前后端框架，要知道当时的我，前端只会一点简单的jquery选择器，后端也就那八次作业的经历而已，直接挑战自己从来没有接触过的东西，真的蛮难的。但是我还是坚持下来了，寒假固然玩的比较多，还是打下来了Mybatis和springboot、vue的基础，就这样边学边写，整整一个月（2.25-3.24）把大作业一个人啃下来了，8k+6k的代码，可以说比我整个大学之前的代码总量都要多的多。这当然不止这三个框架而已，从数据库、java反射、restful、node、npm等等，以前模糊或者不懂得的概念都逐渐变得清晰了。这一门课让我学习了太多太多。&emsp;&emsp;也就是大作业写完的日子，3.23，自己报的字节跳动前端实习一面挂了，也是那天，开始了博客的第一篇文章。 大三下&emsp;&emsp;没错，那又是新的篇章了，面试倒了对沉浸在刚刚1w多行成就的可谓是一记苏醒巴掌。自己只是比以前的自己进步了很多，和别人比还是差了很多的，人外有人，不可骄傲自负。&emsp;&emsp;也许是自己没东西写了，也许是写博客的那股热情过去了，其实是自己肚子里没啥真货，后来很久都没更新了。&emsp;&emsp;这个学期也就czy老师的测试课又在好好听吧，别的也没怎么听，算作前端课的人机交互也没好好学，大作业？哈哈哈，一个字都没动呢现在。这学期自己想静下心来去学一些基础知识却根本做不到，或许在实践中中学习才是最适合我的方法。这学期自己主要的事是去自己尝试写小项目、还有在自己撸npm包，期间顺带学习了解了很多优秀的npm包，如babel/grunt/gulp/webpack/yoeman/chalk/jest/eslint/prettier/travis/coveralls/commder等等,虽然可能也只是简单地了解，但是让自己对前端认识提高了很多。test-chinese,laoyi,v-typewriter,git-info-crawler是自己写的npm包，laogo是自己模仿写出来的的logo生成器网站，还有正在写的latios，是vue的ui组件库。这些东西谈不上多高端，甚至没有能用到的地方，或许还有不少bug，但是看到自己写的东西还是很有成就感的。可能是人更喜欢回忆吧，离自己越近的事情越说不出个所以然，总之自己这段时间的个人开发还是很有帮助的。（PS: 最近这一个月来都在坚持运动，一周最少三次吧，游泳羽毛球吧，锻炼身体学习并重，还是蛮好的） 想说的&emsp;&emsp;又去作死翻了翻我们院大佬cjd的博客和git，觉得自己相比之下真的什么都不是，人家实在是太强了，精通的语言就十多种吧，人家不是搞前端的结果前端比我强得多，所谓人外有人就是这样的吧。但是不能因为和别人差距大就瞧不起自己，这也不是咱们的作风不是吗2333。学无止境，算真正学习我可能也只有3/4个月吧，一口吃不成胖子，以后的路还长呢，人家大佬14年就开始接触编程了，咱不能这么比是吧，我也才大三，还有一年多的本科，还有2年的研究生呢，学习的话怎么都不会迟的，以我这种的个性吧，是不会让自己默默无闻的，总有一天我会和那些现在的大佬齐头并进或者超过他们的，咱们的学习，才刚刚开始不是吗。&emsp;&emsp;好好加油踏实学习就完事了啊！","link":"/2019/06/19/semester-summary/"},{"title":"从Spring和MyBatis来理解反射机制、动态代理模式、责任链模式和观察者模式等（一）","text":"&emsp;寒假写大作业前特地搞了一本《Java EE 互联网轻量级框架整合开发》来看看，这也直接决定了自己后端框架的使用，也学到了一些新的知识。书中有提到动态代理和责任链模式等在Spring与Mybatis的技术原理中有很大的应用，当时因为对设计模式的陌生而且Spring也不是很熟练，就没怎么看懂，java后端的开发的职位面试还是会问到相关的技术实现的。现在决定回头看看，从这两个框架的实现反过来再理解这些设计模式，应该会比直接看设计模式容易得多。 Reflect — 反射技术 &emsp;首先需要了解的是java的反射机制，Java让我们在运行时识别对象和类的信息，主要有2种方式：一种是传统的RTTI，它假定我们在编译时已经知道了所有的类型信息；另一种是反射机制，它允许我们在运行时发现和使用类的信息。&emsp;大家都知道，要让Java程序能够运行，那么就得让Java类要被Java虚拟机加载。Java类如果不被Java虚拟机加载，是不能正常运行的。现在我们运行的所有的程序都是在编译期的时候就已经知道了你所需要的那个类的已经被加载了。&emsp;而Java的反射机制是在编译并不确定是哪个类被加载了，而是在程序运行的时候才加载、探知、自审。使用在编译期并不知道的类。这样的特点就是反射。 初探&emsp;反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。&emsp;简单地说，其实就是动态的从内存加载一个指定的名称的字节码文件对象，并获取该类中的所有的内容。举个栗子，写过数据库的都应该见过这个代码。1Class.forName(\"com.mysql.jdbc.Driver\") &emsp;每一个类都会在编译之后都会产生.class文件，当这个类在第一次使用的时候类加载器(ClassLoader)会加载.class到jvm中，加载就是找到对应的字节码，创建一个Class对象。上述代码就是利用类名来加载了一个jdbcDriver的对象，而我们平时写代码多数时候都是通过new来生成对象，这样的代码在编译的时候就知道了类型信息，而反射机制是正在程序运行时才去从对应字节码去加载这样一个对象。现在再看看最开始的话，应该还算是比较好理解的。 使用&emsp; 前面说到反射机制正在运行状态时可以知道一个类的所有属性和方法，那是怎么实现的呢。是通过java.lang.reflect.*的APIs去取得一个已知名称的class的内部信息。主要包括类、成员变量、构造方法、成员函数、动态数组等。&emsp;其中Java反射机制通常借助Class、Field、Method和Constructor这四个类实现，其中最核心的就是Class类，它是反射的基础，在应用反射机制的过程中我们最关心的一般是一个类的构造器(Constructor类)、属性(Field类)和方法(Method类)。 我们简单地建一个测试类 1234567891011121314151617181920public class TestReflect { private String name; public TestReflect(){ } public TestReflect(String name){ this.name=name; } public void saySomething(String something){ System.err.println(something+\" and \"+name); } public String getName() { return name; } public void setName(String name) { this.name = name; }} Main 123456789101112131415161718192021222324252627282930313233343536373839public class TestMain { public static void main(String[] args){ try { // 根据包名获得类 Class aClass = Class.forName(\"classes.impl.TestReflect\"); // constructor 构造器 无参/有参两种 Constructor constructor1=aClass.getConstructor(); Constructor constructor2=aClass.getConstructor(String.class); // 两种构造器生成对象 Object o2 = (TestReflect) constructor1.newInstance(); Object o1 = (TestReflect) constructor2.newInstance(\"hhh\"); // field 获得属性 为无参构造的注入属性值 Field field = aClass.getDeclaredField(\"name\"); field.setAccessible(true); field.set(o2,\"lol\"); // method 方法调用 Method method = aClass.getMethod(\"saySomething\", String.class); method.setAccessible(true); System.out.println(\"+++++++++++++++++++++++++++\"); method.invoke(o1, \"something\"); System.out.println(\"+++++++++++++++++++++++++++\"); method.invoke(o2,\"something\"); } catch (InstantiationException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } catch (NoSuchMethodException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (NoSuchFieldException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } }} console 1234+++++++++++++++++++++++++++something and hhh+++++++++++++++++++++++++++something and lol &emsp;只是通过其中简单的代表性API展示reflect的应用，详细的api可以去reflect包中阅读源码，不难看出，Java反射中的构造函数，属性，方法有着诸多相似之处，不仅仅是因为它们有着共同的父类AccessibleObject，基本上所有的api都有相似之处，这里不做讨论。&emsp;通过这个简单例子还是比较好理解的，我们通过包名来获得这个类，再通过参数不同获得构造器，以及名字和参数类型去获得属性和方法。让人意外的是getDeclaredField居然可以不通过get方法去获得类的private属性，这个在spring的@Autowired注入里面相信大家都见到过。 个人总结&emsp;很多开源框架例如Spring、MyBatis、Hibernate, 都已使用到了java的反射技术作为整个框架的基础。因为方便的原因，大家都习惯地使用注解去完成一些变量对象的注入，其实最为基础的写法是在xml等配置文件去书写，例如Spring的bean、MyBatis的Mapper。有的人觉得配置文件很繁琐，不如全用java代码去实现多好。&emsp;配置文件的作用在于，如果需求发生变动或者代码需要修改时，必须在java类里去修改，然后再去重新编译，但是对于大型的项目来说重新编译的代价可能比较高。而通过配置文件来实现的话，每次修改只需要在配置文件里去修改就好了，因为配置文件属于静态资源，无需重新编译代码，这无疑降低了成本，大大减少了代码的耦合。代码配置分离，无论是复用性还是灵活性都大大地提高了。&emsp;这就是我在大作业里选择了Mybatis而不是Hibernate的原因之一，虽然学要写的东西多了，但是没有把代码写死，灵活性大大提高，后期修改维护也变得容易多了。 &emsp;Reflect机制也不是完美的，灵活性的同时也违背了Java引以为傲的面向对象的封装性，使用时更应注意扬长避短。","link":"/2019/03/26/J2ee-pattern-1/"},{"title":"设计模式--Visitor模式","text":"临近期末。。才开学一个月就要期末了没错，体系结构还有linux程序设计感觉比较虚，作为老师上课重点讲了好多节课的visitor模式也不是很明白，作业也是半知半懂的情况下完成的，还是有必要把visitor单独拎出来作为一个专题研究一下的才好。以后的时间还得把别的设计模式也好好学学。以下是摘自老师的课件的修改版 Visitor&emsp;visitor,翻译过来就是访问者，visitor模式也就被称为访问者模式&emsp;表示一个作用于某对象结构中的各元素的操作。它使我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作。访问者模式是一种对象行为型模式。 &emsp;为了便于理解，通过实际例子来阐述 &emsp;假设大学里员工（employee）有老师（teacher）和教授（professor）,他们具有相同的属性，名字name,月薪income，假期vacationDays，但是对于两种员工，收入与假期的调整机制不一样，并且要批量进行调整。根据这种情况来设计。 ++模式动机 对于系统中的某些对象，它们存储在同一个集合中，且具有不同的类型，而且对于该集合中的对象，可以接受一类称为访问者的对象来访问，而且不同的访问者其访问方式有所不同，访问者模式为解决这类问题而诞生。 在实际使用时，对同一集合对象的操作并不是唯一的，对相同的元素对象可能存在多种不同的操作方式。 而且这些操作方式并不稳定，可能还需要增加新的操作，以满足新的业务需求。 这时候我们考虑使用访问者模式 ++模式参与者 Visitor 抽象访问者 ConcreteVisitor 具体访问者 Element 抽象元素 ConcreteElement 具体元素 ObjectStructure 对象结构 ++实例代码 Employee 12345678910111213141516171819202122abstract class Employee{ private string name; private double income; private int vacationDays; public string Name{ get{return name;} set{name = value;} } public double Income{ get{return income;} set{income = value;} } public int VacationDays{ get{return vacationDays;} set{vacationDays = value;} } abstract public void Accept(Visitor visitor);} Teacher&amp;Professor 123456789101112131415161718192021class Teacher : Employee{ public Teacher(string name, double income, int vacationDays){ Name = name; Income = income; VacationDays = vacationDays; } public override void Accept(Visitor visitor){ visitor.Visit(this); }}class Professor : Employee{ public Professor(string name, double income,int vacationDays){ Name = name; Income = income; VacationDays = vacationDays; } public override void Accept(Visitor visitor){ visitor.Visit(this); }} Visitor 12345678910111213141516171819202122abstract class Visitor{ abstract public void Visit(Engineer engineer); abstract public void Visit(Teacher teacher);}class IncomeVisitor : Visitor{ public override void Visit(Engineer engineer){ engineer.Income *= 1.1; } public override void Vist(Teacher teacher){ teacher.Income *= 1.2; }}class VacationVisitor : Visitor{ public override void Visit(Engineer engineer){ engineer.VacationDays += 10; } public override void Vist(Teacher teacher){ teacher.VacationDays += 5; }} Employees 1234567891011121314class Employees{ private ArrayList&lt;Employee&gt; employees = new ArrayList(); public Attatch(Employee employee){ employees.add(employee); } public Detach(Employee employee){ employees.Remove(employee); } public Accept(Visitor visitor){ foreach(Employee employee in employees){ employee.Accept(visitor); } }} main代码 123456789101112131415static void main(string[] args){ Teacher zhangsan = new Teacher(\"张三\"， 2500， 100); Professor ldy = new Engineer(\"捞的一\", 12000, 10); Employees list = new Employees(); list.Attatch(zhangsan); list.Attatch(ldy); IncomeVisitor incomeVisitor = new IncomeVisitor(); VacationVisitor vacationVisitor = new VacationVisitor(); list.Accept(incomeVisitor); list.Accept(vacationVisitor); } 模式代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586//Elementabstract class Element{ // Methods abstract public void Accept(Visitor visitor);}//ConcreteElementclass ConcreteElementA : Element{ //Methods override public void Accept(Visitor visitor){ visitor.VisitConreteElementA(this); } public void OperationA(){ }}class ConcreteElementB : Element{ //Methods override public void Accept(Visitor visitor){ visitor.VisitConreteElementB(this); } public void OperationB(){ }}//ObjectStructureclass ObjectStructure{ //Fields private ArrayList elements = new ArrayList(); //Methods public void Attach(Element element){ elements.Add(element); } public void Detach(Element element){ elements.Remove(element); } public void Accept(Visitor visitor){ foreach(Element e in elements) e.Accept(visitor); }}//Visitorabstract class Visitor{ //Methods abstract public void VisitConcreteElementA(ConcreteElementA concreteElementA); abstract public void VisitConcreteElementB(ConcreteElementB concreteElementB); }//ConcreteVisitorclass ConcreteVisitor1 : Visitor{ //Methods override public void VisitConcreteElementA(ConcreteElementA concreteElementA){ console.WriteLine(\"{0} visited by {1}\", concreteElementA, this); } override public void VisitConcreteElementB(ConcreteElementB concreteElementB){ console.WriteLine(\"{0} visited by {1}\", concreteElementB, this); }}class ConcreteVisitor2 : Visitor{ //Methods override public void VisitConcreteElementA(ConcreteElementA concreteElementA){ console.WriteLine(\"{0} visited by {1}\", concreteElementA, this); } override public void VisitConcreteElementB(ConcreteElementB concreteElementB){ console.WriteLine(\"{0} visited by {1}\", concreteElementB, this); }}//Mainstatic void Main(string[] args){ //setup structure ObjectStructure o = new ObjectStructure(); o.Attach(new ConcreteElementA()); o.Attach(new ConcreteElementB()); //create visitor objects ConcreteVisitor1 v1 = new ConcreteVistor1(); ConcreteVisitor2 v2 = new ConcreteVistor2(); //structure accepting visitors o.Accept(v1); o.Accept(v2); Console.ReadKey();} Visitor模式的优劣优点 访问者模式使得增加新的操作变得很容易。如果一些操作依赖于一个复杂的结构对象的话，那么一般而言，增加新的操作会很复杂。而使用访问者模式，增加新的操作就意味着增加一个新的访问者类，因此将变得很容易。 访问者模式将有关的行为集中到一个访问者对象中，而不是分散到一个个的节点类中。 访问者模式可以跨过几个类的等级结构访问属于不同的等级结构的成员类。 缺点 破坏封装。访问者模式要求访问者对象访问并调用每一个节点对象的操作，这隐含了一个对所有节点对象的要求：它们必须暴露一些自己的操作和内部状态。不然，访问者的访问就变得没有意义。由于访问者对象自己会积累访问操作所需的状态，从而使这些状态不再存储在节点对象中，这也是破坏封装的。 增加新的节点类变得很困难。每增加一个新的节点都意味着要在抽象访问者角色中增加一个新的抽象操作，并在每一个具体访问者类中增加相应的具体操作。 适用场景 定义对象结构的类很少改变，但经常要在此结构上的定义新的操作 对象需要添加很多不同的并且不相关的操作，而我们想避免让这些操作“污染”这些对象的类。访问者模式使得我们可以将相关的操作集中起来定义在一个类中。当该对象结构被很多应用共享时，用访问者模式让每个应用仅包含需要用到的操作 模式应用 访问者模式中对象结构存储了不同类型的元素对象，以供不同访问者访问。访问者模式包括两个层次结构，一个是访问者层次结构，提供了抽象访问者和具体访问者，一个是元素层次结构，提供了抽象元素和具体元素。相同的访问者可以以不同的方式访问不同的元素，相同的元素可以接受不同访问者以不同访问方式访问。 在访问者模式中，增加新的访问者无须修改原有系统，系统具有较好的可扩展性。","link":"/2019/03/24/visitor-pattern/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/03/12/hello-world/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"箭头函数","slug":"箭头函数","link":"/tags/箭头函数/"},{"name":"管道","slug":"管道","link":"/tags/管道/"},{"name":"shell","slug":"shell","link":"/tags/shell/"},{"name":"人工智能","slug":"人工智能","link":"/tags/人工智能/"},{"name":"机器学习","slug":"机器学习","link":"/tags/机器学习/"},{"name":"深度学习","slug":"深度学习","link":"/tags/深度学习/"},{"name":"笔试","slug":"笔试","link":"/tags/笔试/"},{"name":"面试","slug":"面试","link":"/tags/面试/"},{"name":"前端","slug":"前端","link":"/tags/前端/"},{"name":"算法","slug":"算法","link":"/tags/算法/"},{"name":"字节跳动","slug":"字节跳动","link":"/tags/字节跳动/"},{"name":"html","slug":"html","link":"/tags/html/"},{"name":"commander.js","slug":"commander-js","link":"/tags/commander-js/"},{"name":"cli","slug":"cli","link":"/tags/cli/"},{"name":"summary","slug":"summary","link":"/tags/summary/"},{"name":"反射机制","slug":"反射机制","link":"/tags/反射机制/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"visitor","slug":"visitor","link":"/tags/visitor/"}],"categories":[{"name":"前端","slug":"前端","link":"/categories/前端/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","link":"/categories/Artificial-Intelligence/"},{"name":"JavaScript","slug":"前端/JavaScript","link":"/categories/前端/JavaScript/"},{"name":"Interviews","slug":"Interviews","link":"/categories/Interviews/"},{"name":"Commands","slug":"Linux/Commands","link":"/categories/Linux/Commands/"},{"name":"ES6","slug":"前端/JavaScript/ES6","link":"/categories/前端/JavaScript/ES6/"},{"name":"Html","slug":"前端/Html","link":"/categories/前端/Html/"},{"name":"npm package","slug":"前端/npm-package","link":"/categories/前端/npm-package/"},{"name":"随记","slug":"随记","link":"/categories/随记/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"J2EE","slug":"Java/J2EE","link":"/categories/Java/J2EE/"},{"name":"Desgin Patterns","slug":"Java/Desgin-Patterns","link":"/categories/Java/Desgin-Patterns/"}]}