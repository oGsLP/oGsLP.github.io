{"pages":[{"title":"分类","text":"","link":"/categories/index.html"}],"posts":[{"title":"字节跳动暑期前端实习笔试 + 一面","text":"上周抱着试一试的心理去参加了班群里内推的字节跳动的暑期前端实习，笔试是在牛客网上做四道算法题，2个小时，前两题很简单做了30分钟就跑过了，后两道题难度有点大，我又是算法没怎么做过，所以光靠脑子还是有点招架不住。不知道是报的前端的原因还是后面两道的确难，也是拿到了面试资格，今天下午3点去试了一下，也是自己第一次求职面试。之前一直在赶大作业，所以就昨天晚上今天早上各两三个小时准备了一点，虽然面试题目其实不是很难但是还是倒了，而且是刚结束一分钟就收到短信说你凉了。。。分享一下，菜勿喷。 笔试 1024元的钞票买n ([0-1024]) 元的商品，共有64,16,4,1这四种硬币，问最少能找零几个硬币。 + 硬币币值差4倍相当于&gt;&gt;2，用移位来做 字符串问题，碰到aabb简化为aab，aaa简化为aa + charAt遍历，分情况讨论，每次简化时记得字符串长度会变 一个数组int[n]代表n个人的分数，n个人围成环，给他们发奖品，每个人至少一个，如果比左右分高，那么奖品也要比左右多，问最少发多少奖品，其中存在 1,2,3,3发奖品为1,2,3,2的情况 + 据说是动态规划的题目，自己不是很了解，记得填坑 一个数组int[n]代表n个绳子的长度，然后告诉你需要的绳子个数num，剪绳子但不能拼接，要求剪出来的绳子长度一样，其中num可能大于或等于或小于n，求剪出来的绳子最长长度是多少（保留2位小数）。 + 一开始当做数学提来写的，但是分情况很细的时候发现不太好讨论了，比如1,1,1,1,100要10根，我更本就不用考虑长度为1的，100分成10*10就完事了。其实可能还是要分解问题去做。。待填坑 我觉得无论如何前两题都得做出来，后两题真的需要大量的练习才能了解解题的技巧，光靠脑子是不行的，还是得加油啊 面试 平时以为自己前端写的还可以，面试问题就全暴露出来了，一堆基础知识掌握不牢，光靠临时抱佛脚还是不行的，js博大精深hhh，还是把我记得的都说出来看看 自我介绍一分钟左右，按照网上说的来历学历项目经验说一说吧，感觉他只对你的项目经验有一点兴趣。 html h5新特性（新标签）=&gt; 新标签的作用用法 css display,position的种类 =&gt; absolute,float导致的流出现覆盖的消除方法 一个定宽高以及不定宽高的块级元素水平居中的方法（margin auto left/right 0 ,flex等） 选择器的优先级 js 一上来问熟悉不熟悉 es2015 基本类型: boolean,string,number,undefined,null。 “还有?” ？？？？ “es15还有symbol” —es15还是很多东西不会的啊 编程题 找出字符串中出现最多的字母以及次数，我的天我居然忘了hash，用数组了。。。。 读程序输出题 我是真的懵逼了。。原型我是真的不会prototype1234567891011121314151617181920212223242526272829var A = function () { function B () { console.log(1); } return this;};A.B=function () { console.log(2);};A.prototype.B=function () { console.log(3);};var B = function () { console.log(4);};B = function () { console.log(5);};A().B;B();A.B();B();new A.B();new A().B(); is not a function;5;2;5;2;3 这题不会真的是js的基本功不行。。加上紧张诶，还是得回去还好练练 读程序setTimeOut123456for(var i = 0 ; i&lt;5 ;i++){ setTimeout(function () { console.log(i); });}console.log(i); 好不容易看到会的了，我一激动说成了一个0五个5，其实后来仔细一看是六个5。。。。 还问了怎么改，这个是会的，let、闭包立即函数 我只是个前端啊，没想到还问数据结构与算法。。。那些我学的都不行啊。。。 算法 冒泡排序bubbleSort123456789101112function bubbleSort(arr){ for(let i=0;i&lt;arr.length-1;i++){ for(let j=0;j&lt;arr.length-1-i;j++){ if(arr[j]&gt;arr[j+1]){ let temp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; } } } return arr;} 快速排序quickSort12345678910111213141516function quickSort(arr){ if(arr.length&lt;=1){return arr;} let pivotIndex=Math.floor(arr.length/2); let pivot=arr.splice(pivotIndex,1)[0]; let left=[]; let right=[]; for(let i=0;i&lt;arr.length;i++){ if(arr[i]&lt;=pivot){ left.push(arr[i]); } else{ right.push(arr[i]); } } return quickSort(left).concat([pivot],quickSort(right));} 这两个特地看了一下，还是会的 数据结构 二叉树我把前中后的顺序记错了。。面试官告诉我顺序还是能弄出来的 队列和栈的区别 我瞎答得，我记得队列先进先出，栈是先进后出 计算机网络 tcp、udp区别 三次握手，四次挥手 1-5的状态码。。细的我记不太清楚了 FAQ最后让我问他一些问题，我其实也没啥好问的，就问了这个工作的一些内容，草草收场了 最后 面试完如释重负，瞬间轻松好多，刚和舍友吐槽一下，叮~，一条短信，“经过慎重考虑，很遗憾你未通过此次面试，如果。。。。。。。。。。。。。。。。。。。。。。。。。。” 加油吧，学习吧，面试什么的下次再战！","link":"/2019/03/23/interview/"},{"title":"ES6--箭头函数","text":"&emsp;刚把jee的大作业写完，其中前端用到了Vue框架，在官方文档和很多教程里都使用了许多箭头函数等es6特性，加之昨天面试字节跳动前端实习的时候问道js的第一句话就是“你了解es2015”吗。写项目的时候模仿去写但是好像上下文this和普通的函数不太一样，后来查文档学习了一下，但还是没有全部理解，现在准备系统地学习一下es6的特性，那么就先从箭头函数开始吧 基本语法12345678910111213141516(aruguments) =&gt; {statements}x =&gt; x+2 // 单参省略括号，单语句且为返回值省略大括号()=&gt;{} // 无参保留()*********************************************//加括号的函数体返回对象字面表达式：参数=&gt; ({foo: bar})//支持剩余参数和默认参数(参数1, 参数2, ...rest) =&gt; {函数声明}(参数1 = 默认值1,参数2, …, 参数N = 默认值N) =&gt; {函数声明}//同样支持参数列表解构let f = ([a, b] = [1, 2], {x: c} = {x: a + b}) =&gt; a + b + c;f(); // 6 官网对与箭头函数的描述有两个特点，一个是更简短，另一个则是不绑定this，举例来说明123456function Test(){ this.val = 0; setInterval(function test(){ this.val++; },1000);} &emsp;因为setInterval中的function的this上下文是全局对象，所以test里的this.val和对象的val不一样，一般采用bind(this)或者self/that=this,在setInterval中调用that来获得对象上下文，而箭头函数则是不绑定this，具体原因是因为箭头函数没有prototype，它只会从自己的作用域链的上一层继承this上下文，如下123456function Test(){ this.val = 0; setInterval(()=&gt;{ this.val++; },1000);} &emsp;如果拿我自己的大作业的例子来说就是在尝试promise、then的时候发现this上下文的问题，一开始用bind来解决，后来接触箭头函数，就直接用箭头函数改写了方法，但是当时不知道箭头函数的this直接继承，后来发现，觉得真的很方便，简化了繁琐的bind，直接上实际例子。123456789101112131415161718192021222324252627282930//改造前pay_deal(){ new Promise(function (resolve) { // 略 resolve(val_1); }.bind(this)) .then(function (val_1){ return new Promise(function (resolve) { // 略 resolve(val_2); }.bind(this)); }.bind(this)) .then(function (val_2) { // 略 }.bind(this));},//改造后pay_deal(){ new Promise(resolve =&gt; { // 略 resolve(val_1) }); }).then(val_1=&gt;new Promise(resolve =&gt; { // 略 resolve(val_2) } })).then(val_2=&gt;{ // 略 });}, &emsp;效果很明显，省去了繁琐的this绑定，特别在promise的then连写的时候，return new promise需要两次绑定，简直就是灾难，用箭头函数瞬间清爽了很多。 FAQ &emsp; 若是箭头函数的外层没有普通函数呢？ 普通函数的默认绑定规则是，非严格模式下this指向全局，严格模式下为undefined 箭头函数在全局作用域下，严格模式与非严格模式下都会指向window(全局对象) 以上是箭头函数基本的两个概念，也是最简单的应用，还有很多实际的复杂情况和别的技术混合使用的例子 apply/call调用&emsp;由于箭头函数没有自己的this，通过apply或者call调用的时候只能传递参数，而第一个参数–上下文将被忽略，同样，箭头函数调用bind也是徒劳之举，webstorm会直接提醒错误 1234567891011121314151617181920var adder = { base : 1, add : function(a) { var f = v =&gt; v + this.base; return f(a); }, addThruCall: function(a) { var f = v =&gt; v + this.base; var b = { base : 2 }; return f.call(b, a); }};console.log(adder.add(1)); // 输出 2console.log(adder.addThruCall(1)); // 仍然输出 2（而不是3 ——译者注） 参数调用&emsp;箭头函数同样不绑定arguments参数，若是全局下的箭头函数，arguments指向全局，会出现arguments未声明的错误。而当箭头函数的this指向普通函数时，它的arguments同样继承自普通函数，这点还是很好理解的，也是可以利用这个特性去处理外层函数的不定参数。&emsp;但是如果需要获得箭头函数的不定量参数呢，没有了arguments怎么做？这就要用到es6的另一个特性，rest参数(…扩展符)。 1234567let fun = (x, ...args)=&gt;{ console.log(x); console.log(args);};fun(1,2,3);// 1// [2,3] &emsp;rest参数的详细会再出一个文章介绍，现在大致先了解一下，rest和arguments的区别在于rest是一个真正的数组，可以使用数组的api。rest在普通函数和箭头函数中都可以使用，但必须作为函数参数的最后一位，剩余参数嘛，字面意思也可以理解。 其他 箭头函数不能使用构造器，使用new会报错 箭头函数没有prototype new.target指向外层函数的引用 箭头函数不支持重命名函数参数，而不同函数的重复参数后面的会覆盖前面的 注意事项 一条语句返回对象字面量，需要加括号或者直接写成多条语句的return形式。说到这里我好像明白了vue的比较新的版本里data都是return一个对象了，而不是直接写，一个就是这个原因吧，可能vue的解析将其作为箭头函数了 12345data:{ return{ foo: bar }} 箭头函数的参数和箭头之间不能换行 123let fun = () =&gt; 1// 报错 箭头函数的解析顺序相对靠前，虽然箭头不是运算符，但是箭头函数具有与常规函数不同的特殊运算符优先级解析规则。 12let bool = false || ()=&gt;true;// 箭头函数先执行，false则因为懒惰机制不会参与计算 使用&emsp;箭头函数在一些简单的运算处理中是很方便简洁的，但是在复杂的逻辑以及多重嵌套里，因为上下文的确定有一定难度，造成代码可读性差。一句话来说就是，箭头函数更适合非方法的函数，或者本来就是需要作为匿名函数的地方，因为箭头函数也是匿名函数。 &emsp;关于箭头函数的使用仁者见仁，智者见智，箭头函数也是一把双刃剑，用在恰当的地方就像庖丁解牛一样游刃有余，滥用则会造成许多不必要的问题。如何使用的最佳实践，还是需要在代码中不断尝试才能知道。","link":"/2019/03/24/arrow-function/"},{"title":"ES6--模板字符串","text":"&emsp;软工三的时候大作业都采用了原生的一些方法，很多时候会碰到字符串里面引号错乱很头疼的时候，包括获得request的内容也是在jsp中嵌入java代码再转成js对象。j2ee的大作业接触了更多的技术后才发现嵌入代码或者数据的好处，例如jsp中使用el表达式，mustache语法在themeleaf和vue,angular等中的运用。其中还是js的es6新特性模板字符串让我最为欣赏。 模板字符串&emsp;其实原生的js里就有模板字符串的运用了，特别是在js操作新建dom的时候，例如123456$('#result').append( 'There are &lt;b&gt;' + basket.count + '&lt;/b&gt; ' + 'items in your basket, ' + '&lt;em&gt;' + basket.onSale + '&lt;/em&gt; are on sale!'); &emsp;这样的话要写很多的+和’’以及””,特别是嵌套的时候会出现各种复杂的问题，让人很难受，新的模板字符串特性使用反向引号和${}来完成字符串的拼接组成。12345$('#result').append(` There are &lt;b&gt;${basket.count}&lt;/b&gt; items in your basket, &lt;em&gt;${basket.onSale}&lt;/em&gt; are on sale!`); &emsp;少了很多引号和加号，瞬间会清爽很多吧。&emsp;写大作业的时候第一次了解到这个的时候瞬间有一种亲切感，那是因为不是第一次接触这个了，在自己学习perl的时候也碰到了几乎一样的定义，这比java繁琐的字符串操作要方便多了。有了这个，写大作业的时候可以说是游刃有余，特别在axios请求的url中需要一些动态生成的值，直接使用`/api/member/${member_id}`就行了。 其他&emsp;其实模板字符串并没有太多的内容，以上基本就是所有用法了，还有以下一些注意事项。 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。 大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性，而且还能调用函数(这点和vue使用的mustache语法很像) 如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。 模板字符串甚至还能嵌套。 1234567891011121314151617181920212223const tmpl = addrs =&gt; ` &lt;table&gt; ${addrs.map(addr =&gt; ` &lt;tr&gt;&lt;td&gt;${addr.first}&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;${addr.last}&lt;/td&gt;&lt;/tr&gt; `).join('')} &lt;/table&gt;`;const data = [ { first: '&lt;Jane&gt;', last: 'Bond' }, { first: 'Lars', last: '&lt;Croft&gt;' },];console.log(tmpl(data));// &lt;table&gt;//// &lt;tr&gt;&lt;td&gt;&lt;Jane&gt;&lt;/td&gt;&lt;/tr&gt;// &lt;tr&gt;&lt;td&gt;Bond&lt;/td&gt;&lt;/tr&gt;//// &lt;tr&gt;&lt;td&gt;Lars&lt;/td&gt;&lt;/tr&gt;// &lt;tr&gt;&lt;td&gt;&lt;Croft&gt;&lt;/td&gt;&lt;/tr&gt;//// &lt;/table&gt; 可以引用模板字符串本身执行 123456789// 写法一let str = 'return ' + '`Hello ${name}!`';let func = new Function('name', str);func('Jack') // \"Hello Jack!\"// 写法二let str = '(name) =&gt; `Hello ${name}!`';let func = eval.call(null, str);func('Jack') // \"Hello Jack!\" 应用&emsp;配合正则表达式等，模板字符串还有一些实用的技巧 摘自阮一峰老师的es6教程下面，我们来看一个通过模板字符串，生成正式模板的实例。 1234567let template = `&lt;ul&gt; &lt;% for(let i=0; i &lt; data.supplies.length; i++) { %&gt; &lt;li&gt;&lt;%= data.supplies[i] %&gt;&lt;/li&gt; &lt;% } %&gt;&lt;/ul&gt;`; 上面代码在模板字符串之中，放置了一个常规模板。该模板使用&lt;%...%&gt;放置 JavaScript 代码，使用&lt;%= ... %&gt;输出 JavaScript 表达式。 怎么编译这个模板字符串呢？ 一种思路是将其转换为 JavaScript 表达式字符串。 1234567echo('&lt;ul&gt;');for(let i=0; i &lt; data.supplies.length; i++) { echo('&lt;li&gt;'); echo(data.supplies[i]); echo('&lt;/li&gt;');};echo('&lt;/ul&gt;'); 这个转换使用正则表达式就行了。 12345678let evalExpr = /&lt;%=(.+?)%&gt;/g;let expr = /&lt;%([\\s\\S]+?)%&gt;/g;template = template .replace(evalExpr, '`); \\n echo( $1 ); \\n echo(`') .replace(expr, '`); \\n $1 \\n echo(`');template = 'echo(`' + template + '`);'; 然后，将template封装在一个函数里面返回，就可以了。 1234567891011121314let script =`(function parse(data){ let output = \"\"; function echo(html){ output += html; } ${ template } return output;})`;return script; 将上面的内容拼装成一个模板编译函数compile。 12345678910111213141516171819202122232425function compile(template){ const evalExpr = /&lt;%=(.+?)%&gt;/g; const expr = /&lt;%([\\s\\S]+?)%&gt;/g; template = template .replace(evalExpr, '`); \\n echo( $1 ); \\n echo(`') .replace(expr, '`); \\n $1 \\n echo(`'); template = 'echo(`' + template + '`);'; let script = `(function parse(data){ let output = \"\"; function echo(html){ output += html; } ${ template } return output; })`; return script;} compile函数的用法如下。 1234567let parse = eval(compile(template));div.innerHTML = parse({ supplies: [ \"broom\", \"mop\", \"cleaner\" ] });// &lt;ul&gt;// &lt;li&gt;broom&lt;/li&gt;// &lt;li&gt;mop&lt;/li&gt;// &lt;li&gt;cleaner&lt;/li&gt;// &lt;/ul&gt; 标签模板模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。 123alert`123`// 等同于alert(123) 标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。 但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。 123456let a = 5;let b = 10;tag`Hello ${ a + b } world ${ a * b }`;// 等同于tag(['Hello ', ' world ', ''], 15, 50); 上面代码中，模板字符串前面有一个标识名tag，它是一个函数。整个表达式的返回值，就是tag函数处理模板字符串后的返回值。 函数tag依次会接收到多个参数。 123456789function tag(stringArr, value1, value2){ // ...}// 等同于function tag(stringArr, ...values){ // ...} tag函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。 tag函数的其他参数，都是模板字符串各个变量被替换后的值。由于本例中，模板字符串含有两个变量，因此tag会接受到value1和value2两个参数。 tag函数所有参数的实际值如下。 第一个参数：['Hello ', ' world ', ''] 第二个参数: 15 第三个参数：50 也就是说，tag函数实际上以下面的形式调用。 1tag(['Hello ', ' world ', ''], 15, 50) 我们可以按照需要编写tag函数的代码。下面是tag函数的一种写法，以及运行结果。 1234567891011121314151617181920let a = 5;let b = 10;function tag(s, v1, v2) { console.log(s[0]); console.log(s[1]); console.log(s[2]); console.log(v1); console.log(v2); return \"OK\";}tag`Hello ${ a + b } world ${ a * b}`;// \"Hello \"// \" world \"// \"\"// 15// 50// \"OK\" 下面是一个更复杂的例子。 123456789101112131415161718let total = 30;let msg = passthru`The total is ${total} (${total*1.05} with tax)`;function passthru(literals) { let result = ''; let i = 0; while (i &lt; literals.length) { result += literals[i++]; if (i &lt; arguments.length) { result += arguments[i]; } } return result;}msg // \"The total is 30 (31.5 with tax)\" 上面这个例子展示了，如何将各个参数按照原来的位置拼合回去。 passthru函数采用 rest 参数的写法如下。 12345678910function passthru(literals, ...values) { let output = \"\"; let index; for (index = 0; index &lt; values.length; index++) { output += literals[index] + values[index]; } output += literals[index] return output;} “标签模板”的一个重要应用，就是过滤 HTML 字符串，防止用户输入恶意内容。 123456789101112131415161718let message = SaferHTML`&lt;p&gt;${sender} has sent you a message.&lt;/p&gt;`;function SaferHTML(templateData) { let s = templateData[0]; for (let i = 1; i &lt; arguments.length; i++) { let arg = String(arguments[i]); // Escape special characters in the substitution. s += arg.replace(/&amp;/g, \"&amp;amp;\") .replace(/&lt;/g, \"&amp;lt;\") .replace(/&gt;/g, \"&amp;gt;\"); // Don't escape special characters in the template. s += templateData[i]; } return s;} 上面代码中，sender变量往往是用户提供的，经过SaferHTML函数处理，里面的特殊字符都会被转义。 12345let sender = '&lt;script&gt;alert(\"abc\")&lt;/script&gt;'; // 恶意代码let message = SaferHTML`&lt;p&gt;${sender} has sent you a message.&lt;/p&gt;`;message// &lt;p&gt;&amp;lt;script&amp;gt;alert(\"abc\")&amp;lt;/script&amp;gt; has sent you a message.&lt;/p&gt; 标签模板的另一个应用，就是多语言转换（国际化处理）。 12i18n`Welcome to ${siteName}, you are visitor number ${visitorNumber}!`// \"欢迎访问xxx，您是第xxxx位访问者！\" 模板字符串本身并不能取代 Mustache 之类的模板库，因为没有条件判断和循环处理功能，但是通过标签函数，你可以自己添加这些功能。 123456789// 下面的hashTemplate函数// 是一个自定义的模板处理函数let libraryHtml = hashTemplate` &lt;ul&gt; #for book in ${myBooks} &lt;li&gt;&lt;i&gt;#{book.title}&lt;/i&gt; by #{book.author}&lt;/li&gt; #end &lt;/ul&gt;`; 除此之外，你甚至可以使用标签模板，在 JavaScript 语言之中嵌入其他语言。 123456789jsx` &lt;div&gt; &lt;input ref='input' onChange='${this.handleChange}' defaultValue='${this.state.value}' /&gt; ${this.state.value} &lt;/div&gt;` 上面的代码通过jsx函数，将一个 DOM 字符串转为 React 对象。你可以在 GitHub 找到jsx函数的具体实现。 下面则是一个假想的例子，通过java函数，在 JavaScript 代码之中运行 Java 代码。 12345678java`class HelloWorldApp { public static void main(String[] args) { System.out.println(\"Hello World!\"); // Display the string. }}`HelloWorldApp.main(); 模板处理函数的第一个参数（模板字符串数组），还有一个raw属性。 12console.log`123`// [\"123\", raw: Array[1]] 上面代码中，console.log接受的参数，实际上是一个数组。该数组有一个raw属性，保存的是转义后的原字符串。 请看下面的例子。 1234567tag`First line\\nSecond line`function tag(strings) { console.log(strings.raw[0]); // strings.raw[0] 为 \"First line\\\\nSecond line\" // 打印输出 \"First line\\nSecond line\"} 上面代码中，tag函数的第一个参数strings，有一个raw属性，也指向一个数组。该数组的成员与strings数组完全一致。比如，strings数组是[&quot;First line\\nSecond line&quot;]，那么strings.raw数组就是[&quot;First line\\\\nSecond line&quot;]。两者唯一的区别，就是字符串里面的斜杠都被转义了。比如，strings.raw 数组会将\\n视为\\\\和n两个字符，而不是换行符。这是为了方便取得转义之前的原始模板而设计的。","link":"/2019/03/24/template-string/"},{"title":"设计模式--Visitor模式","text":"临近期末。。才开学一个月就要期末了没错，体系结构还有linux程序设计感觉比较虚，作为老师上课重点讲了好多节课的visitor模式也不是很明白，作业也是半知半懂的情况下完成的，还是有必要把visitor单独拎出来作为一个专题研究一下的才好。以后的时间还得把别的设计模式也好好学学。以下是摘自老师的课件的修改版 Visitor&emsp;visitor,翻译过来就是访问者，visitor模式也就被称为访问者模式&emsp;表示一个作用于某对象结构中的各元素的操作。它使我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作。访问者模式是一种对象行为型模式。 &emsp;为了便于理解，通过实际例子来阐述 &emsp;假设大学里员工（employee）有老师（teacher）和教授（professor）,他们具有相同的属性，名字name,月薪income，假期vacationDays，但是对于两种员工，收入与假期的调整机制不一样，并且要批量进行调整。根据这种情况来设计。 ++模式动机 对于系统中的某些对象，它们存储在同一个集合中，且具有不同的类型，而且对于该集合中的对象，可以接受一类称为访问者的对象来访问，而且不同的访问者其访问方式有所不同，访问者模式为解决这类问题而诞生。 在实际使用时，对同一集合对象的操作并不是唯一的，对相同的元素对象可能存在多种不同的操作方式。 而且这些操作方式并不稳定，可能还需要增加新的操作，以满足新的业务需求。 这时候我们考虑使用访问者模式 ++模式参与者 Visitor 抽象访问者 ConcreteVisitor 具体访问者 Element 抽象元素 ConcreteElement 具体元素 ObjectStructure 对象结构 ++实例代码 Employee 12345678910111213141516171819202122abstract class Employee{ private string name; private double income; private int vacationDays; public string Name{ get{return name;} set{name = value;} } public double Income{ get{return income;} set{income = value;} } public int VacationDays{ get{return vacationDays;} set{vacationDays = value;} } abstract public void Accept(Visitor visitor);} Teacher&amp;Professor 123456789101112131415161718192021class Teacher : Employee{ public Teacher(string name, double income, int vacationDays){ Name = name; Income = income; VacationDays = vacationDays; } public override void Accept(Visitor visitor){ visitor.Visit(this); }}class Professor : Employee{ public Professor(string name, double income,int vacationDays){ Name = name; Income = income; VacationDays = vacationDays; } public override void Accept(Visitor visitor){ visitor.Visit(this); }} Visitor 12345678910111213141516171819202122abstract class Visitor{ abstract public void Visit(Engineer engineer); abstract public void Visit(Teacher teacher);}class IncomeVisitor : Visitor{ public override void Visit(Engineer engineer){ engineer.Income *= 1.1; } public override void Vist(Teacher teacher){ teacher.Income *= 1.2; }}class VacationVisitor : Visitor{ public override void Visit(Engineer engineer){ engineer.VacationDays += 10; } public override void Vist(Teacher teacher){ teacher.VacationDays += 5; }} Employees 1234567891011121314class Employees{ private ArrayList&lt;Employee&gt; employees = new ArrayList(); public Attatch(Employee employee){ employees.add(employee); } public Detach(Employee employee){ employees.Remove(employee); } public Accept(Visitor visitor){ foreach(Employee employee in employees){ employee.Accept(visitor); } }} main代码 123456789101112131415static void main(string[] args){ Teacher zhangsan = new Teacher(\"张三\"， 2500， 100); Professor ldy = new Engineer(\"捞的一\", 12000, 10); Employees list = new Employees(); list.Attatch(zhangsan); list.Attatch(ldy); IncomeVisitor incomeVisitor = new IncomeVisitor(); VacationVisitor vacationVisitor = new VacationVisitor(); list.Accept(incomeVisitor); list.Accept(vacationVisitor); } 模式代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586//Elementabstract class Element{ // Methods abstract public void Accept(Visitor visitor);}//ConcreteElementclass ConcreteElementA : Element{ //Methods override public void Accept(Visitor visitor){ visitor.VisitConreteElementA(this); } public void OperationA(){ }}class ConcreteElementB : Element{ //Methods override public void Accept(Visitor visitor){ visitor.VisitConreteElementB(this); } public void OperationB(){ }}//ObjectStructureclass ObjectStructure{ //Fields private ArrayList elements = new ArrayList(); //Methods public void Attach(Element element){ elements.Add(element); } public void Detach(Element element){ elements.Remove(element); } public void Accept(Visitor visitor){ foreach(Element e in elements) e.Accept(visitor); }}//Visitorabstract class Visitor{ //Methods abstract public void VisitConcreteElementA(ConcreteElementA concreteElementA); abstract public void VisitConcreteElementB(ConcreteElementB concreteElementB); }//ConcreteVisitorclass ConcreteVisitor1 : Visitor{ //Methods override public void VisitConcreteElementA(ConcreteElementA concreteElementA){ console.WriteLine(\"{0} visited by {1}\", concreteElementA, this); } override public void VisitConcreteElementB(ConcreteElementB concreteElementB){ console.WriteLine(\"{0} visited by {1}\", concreteElementB, this); }}class ConcreteVisitor2 : Visitor{ //Methods override public void VisitConcreteElementA(ConcreteElementA concreteElementA){ console.WriteLine(\"{0} visited by {1}\", concreteElementA, this); } override public void VisitConcreteElementB(ConcreteElementB concreteElementB){ console.WriteLine(\"{0} visited by {1}\", concreteElementB, this); }}//Mainstatic void Main(string[] args){ //setup structure ObjectStructure o = new ObjectStructure(); o.Attach(new ConcreteElementA()); o.Attach(new ConcreteElementB()); //create visitor objects ConcreteVisitor1 v1 = new ConcreteVistor1(); ConcreteVisitor2 v2 = new ConcreteVistor2(); //structure accepting visitors o.Accept(v1); o.Accept(v2); Console.ReadKey();} Visitor模式的优劣优点 访问者模式使得增加新的操作变得很容易。如果一些操作依赖于一个复杂的结构对象的话，那么一般而言，增加新的操作会很复杂。而使用访问者模式，增加新的操作就意味着增加一个新的访问者类，因此将变得很容易。 访问者模式将有关的行为集中到一个访问者对象中，而不是分散到一个个的节点类中。 访问者模式可以跨过几个类的等级结构访问属于不同的等级结构的成员类。 缺点 破坏封装。访问者模式要求访问者对象访问并调用每一个节点对象的操作，这隐含了一个对所有节点对象的要求：它们必须暴露一些自己的操作和内部状态。不然，访问者的访问就变得没有意义。由于访问者对象自己会积累访问操作所需的状态，从而使这些状态不再存储在节点对象中，这也是破坏封装的。 增加新的节点类变得很困难。每增加一个新的节点都意味着要在抽象访问者角色中增加一个新的抽象操作，并在每一个具体访问者类中增加相应的具体操作。 适用场景 定义对象结构的类很少改变，但经常要在此结构上的定义新的操作 对象需要添加很多不同的并且不相关的操作，而我们想避免让这些操作“污染”这些对象的类。访问者模式使得我们可以将相关的操作集中起来定义在一个类中。当该对象结构被很多应用共享时，用访问者模式让每个应用仅包含需要用到的操作 模式应用 访问者模式中对象结构存储了不同类型的元素对象，以供不同访问者访问。访问者模式包括两个层次结构，一个是访问者层次结构，提供了抽象访问者和具体访问者，一个是元素层次结构，提供了抽象元素和具体元素。相同的访问者可以以不同的方式访问不同的元素，相同的元素可以接受不同访问者以不同访问方式访问。 在访问者模式中，增加新的访问者无须修改原有系统，系统具有较好的可扩展性。","link":"/2019/03/24/visitor-pattern/"},{"title":"人工智能、机器学习、深度学习三者","text":"借着期末复习（预习）体系结构这门课的契机，稍微了解了一点关于人工智能(Artificial Intelligence), 机器学习(Machine Learning), 深度学习(Deep Learning)的知识，之前对此还是完全不知所云的状态，现在决定初探其中的奥妙。首先，弄清楚这三者的关系。 &emsp;三者关系其实很简单，就如这张图所示，是一个包含关系，逐层深入。 人工智能&emsp;1956年，几个计算机科学家相聚在达特茅斯会议，提出了“人工智能”的概念，梦想着用当时刚刚出现的计算机来构造复杂的、拥有与人类智慧同样本质特性的机器。 &emsp;2012年以后，得益于数据量的上涨、运算力的提升和机器学习新算法（深度学习）的出现，人工智能开始大爆发。人工智能的研究领域也在不断扩大，人工智能研究的各个分支，包括专家系统、机器学习、进化计算、模糊逻辑、计算机视觉、自然语言处理、推荐系统等。可见机器学习只是人工智能的一部分，但也是最活跃的一部分。 &emsp;但目前的科研工作都集中在弱人工智能这部分，并很有希望在近期取得重大突破，电影里的人工智能多半都是在描绘强人工智能，而这部分在目前的现实世界里难以真正实现（通常将人工智能分为弱人工智能和强人工智能，前者让机器具备观察和感知的能力，可以做到一定程度的理解和推理，而强人工智能让机器获得自适应能力，解决一些之前没有遇到过的问题）。 &emsp;举个简单的例子吧，强智能就像守望先锋里面的智能机械，弱智能好比艾什的bob(hhh)。 机器学习&emsp;机器学习其实是一种实现人工智能的方法 &emsp; 机器学习最基本的做法，是使用算法来解析数据、从中学习，然后对真实世界中的事件做出决策和预测。 与传统的为解决特定任务、硬编码的软件程序不同，机器学习是用大量的数据来“训练”，通过各种算法从数据中学习如何完成任务。 &emsp;机器学习直接来源于早期的人工智能领域。传统算法包括决策树学习、推导逻辑规划、聚类、强化学习和贝叶斯网络等等。众所周知，我们还没有实现强人工智能。早期机器学习方法甚至都无法实现弱人工智能。 &emsp; 机器学习最成功的应用领域是计算机视觉， 虽然也还是需要大量的手工编码来完成工作。人们需要手工编写分类器、边缘检测滤波器，以便让程序能识别物体从哪里开始，到哪里结束；写形状检测程序来判断检测对象是不是有八条边；写分类器来识别字母“ST-O-P”。使用以上这些手工编写的分类器，人们总算可以开发算法来感知图像，判断图像是不是一个停止标志牌。 &emsp;这个结果还算不错，但并不是那种能让人为之一振的成功。特别是遇到云雾天，标志牌变得不是那么清晰可见，又或者被树遮挡一部分，算法就难以成功了。这就是为什么前一段时间，计算机视觉的性能一直无法接近到人的能力。它太僵化，太容易受环境条件的干扰。 &emsp;随着时间的推进，学习算法的发展改变了一切。 深度学习&emsp;人工神经网络（Artificial Neural Networks）是早期机器学习中的一个重要的算法，历经数十年风风雨雨。神经网络的原理是受我们大脑的生理结构——互相交叉相连的神经元启发。但与大脑中一个神经元可以连接一定距离内的任意神经元不同，人工神经网络具有离散的层、连接和数据传播的方向。 &emsp;例如，我们可以把一幅图像切分成图像块，输入到神经网络的第一层。在第一层的每一个神经元都把数据传递到第二层。第二层的神经元也是完成类似的工作，把数据传递到第三层，以此类推，直到最后一层，然后生成结果。 &emsp;每一个神经元都为它的输入分配权重，这个权重的正确与否与其执行的任务直接相关。最终的输出由这些权重加总来决定。 &emsp;我们仍以停止（Stop）标志牌为例。将一个停止标志牌图像的所有元素都打碎，然后用神经元进行“检查”：八边形的外形、救火车般的红颜色、鲜明突出的字母、交通标志的典型尺寸和静止不动运动特性等等。神经网络的任务就是给出结论，它到底是不是一个停止标志牌。神经网络会根据所有权重，给出一个经过深思熟虑的猜测——“概率向量”。 &emsp;这个例子里，系统可能会给出这样的结果：86%可能是一个停止标志牌；7%的可能是一个限速标志牌；5%的可能是一个风筝挂在树上等等。然后网络结构告知神经网络，它的结论是否正确。 &emsp;即使是这个例子，也算是比较超前了。直到前不久，神经网络也还是为人工智能圈所淡忘。其实在人工智能出现的早期，神经网络就已经存在了，但神经网络对于“智能”的贡献微乎其微。主要问题是，即使是最基本的神经网络，也需要大量的运算。神经网络算法的运算需求难以得到满足。 &emsp;不过，还是有一些虔诚的研究团队，以多伦多大学的Geoffrey Hinton为代表，坚持研究，实现了以超算为目标的并行算法的运行与概念证明。但也直到GPU得到广泛应用，这些努力才见到成效。 &emsp;我们回过头来看这个停止标志识别的例子。神经网络是调制、训练出来的，时不时还是很容易出错的。它最需要的，就是训练。需要成百上千甚至几百万张图像来训练，直到神经元的输入的权值都被调制得十分精确，无论是否有雾，晴天还是雨天，每次都能得到正确的结果。 &emsp;只有这个时候，我们才可以说神经网络成功地自学习到一个停止标志的样子；或者在Facebook的应用里，神经网络自学习了你妈妈的脸；又或者是2012年吴恩达（Andrew Ng）教授在Google实现了神经网络学习到猫的样子等等。 &emsp;吴教授的突破在于，把这些神经网络从基础上显著地增大了。层数非常多，神经元也非常多，然后给系统输入海量的数据，来训练网络。在吴教授这里，数据是一千万YouTube视频中的图像。吴教授为深度学习（deep learning）加入了“深度”（deep）。这里的“深度”就是说神经网络中众多的层。 &emsp;现在，经过深度学习训练的图像识别，在一些场景中甚至可以比人做得更好：从识别猫，到辨别血液中癌症的早期成分，到识别核磁共振成像中的肿瘤。Google的AlphaGo先是学会了如何下围棋，然后与它自己下棋训练。它训练自己神经网络的方法，就是不断地与自己下棋，反复地下，永不停歇。 &emsp;深度学习，给人工智能以璀璨的未来。&emsp;深度学习使得机器学习能够实现众多的应用，并拓展了人工智能的领域范围。深度学习摧枯拉朽般地实现了各种任务，使得似乎所有的机器辅助功能都变为可能。无人驾驶汽车，预防性医疗保健，甚至是更好的电影推荐，都近在眼前，或者即将实现。 &emsp;转载: https://www.cnblogs.com/dadadechengzi/articles/6575767.html &emsp;最后期待一下deepmind战胜星际争霸2的世界冠军的那一天究竟什么时候能够到来，serral也好，Innovation也好。","link":"/2019/03/25/ai-ml-dl/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/03/12/hello-world/"},{"title":"从Spring和MyBatis来理解反射机制、动态代理模式、责任链模式和观察者模式等（一）","text":"&emsp;寒假写大作业前特地搞了一本《Java EE 互联网轻量级框架整合开发》来看看，这也直接决定了自己后端框架的使用，也学到了一些新的知识。书中有提到动态代理和责任链模式等在Spring与Mybatis的技术原理中有很大的应用，当时因为对设计模式的陌生而且Spring也不是很熟练，就没怎么看懂，java后端的开发的职位面试还是会问到相关的技术实现的。现在决定回头看看，从这两个框架的实现反过来再理解这些设计模式，应该会比直接看设计模式容易得多。 Reflect — 反射技术 &emsp;首先需要了解的是java的反射机制，Java让我们在运行时识别对象和类的信息，主要有2种方式：一种是传统的RTTI，它假定我们在编译时已经知道了所有的类型信息；另一种是反射机制，它允许我们在运行时发现和使用类的信息。&emsp;大家都知道，要让Java程序能够运行，那么就得让Java类要被Java虚拟机加载。Java类如果不被Java虚拟机加载，是不能正常运行的。现在我们运行的所有的程序都是在编译期的时候就已经知道了你所需要的那个类的已经被加载了。&emsp;而Java的反射机制是在编译并不确定是哪个类被加载了，而是在程序运行的时候才加载、探知、自审。使用在编译期并不知道的类。这样的特点就是反射。 初探&emsp;反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。&emsp;简单地说，其实就是动态的从内存加载一个指定的名称的字节码文件对象，并获取该类中的所有的内容。举个栗子，写过数据库的都应该见过这个代码。1Class.forName(\"com.mysql.jdbc.Driver\") &emsp;每一个类都会在编译之后都会产生.class文件，当这个类在第一次使用的时候类加载器(ClassLoader)会加载.class到jvm中，加载就是找到对应的字节码，创建一个Class对象。上述代码就是利用类名来加载了一个jdbcDriver的对象，而我们平时写代码多数时候都是通过new来生成对象，这样的代码在编译的时候就知道了类型信息，而反射机制是正在程序运行时才去从对应字节码去加载这样一个对象。现在再看看最开始的话，应该还算是比较好理解的。 使用&emsp; 前面说到反射机制正在运行状态时可以知道一个类的所有属性和方法，那是怎么实现的呢。是通过java.lang.reflect.*的APIs去取得一个已知名称的class的内部信息。主要包括类、成员变量、构造方法、成员函数、动态数组等。&emsp;其中Java反射机制通常借助Class、Field、Method和Constructor这四个类实现，其中最核心的就是Class类，它是反射的基础，在应用反射机制的过程中我们最关心的一般是一个类的构造器(Constructor类)、属性(Field类)和方法(Method类)。 我们简单地建一个测试类 1234567891011121314151617181920public class TestReflect { private String name; public TestReflect(){ } public TestReflect(String name){ this.name=name; } public void saySomething(String something){ System.err.println(something+\" and \"+name); } public String getName() { return name; } public void setName(String name) { this.name = name; }} Main 123456789101112131415161718192021222324252627282930313233343536373839public class TestMain { public static void main(String[] args){ try { // 根据包名获得类 Class aClass = Class.forName(\"classes.impl.TestReflect\"); // constructor 构造器 无参/有参两种 Constructor constructor1=aClass.getConstructor(); Constructor constructor2=aClass.getConstructor(String.class); // 两种构造器生成对象 Object o2 = (TestReflect) constructor1.newInstance(); Object o1 = (TestReflect) constructor2.newInstance(\"hhh\"); // field 获得属性 为无参构造的注入属性值 Field field = aClass.getDeclaredField(\"name\"); field.setAccessible(true); field.set(o2,\"lol\"); // method 方法调用 Method method = aClass.getMethod(\"saySomething\", String.class); method.setAccessible(true); System.out.println(\"+++++++++++++++++++++++++++\"); method.invoke(o1, \"something\"); System.out.println(\"+++++++++++++++++++++++++++\"); method.invoke(o2,\"something\"); } catch (InstantiationException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } catch (NoSuchMethodException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (NoSuchFieldException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } }} console 1234+++++++++++++++++++++++++++something and hhh+++++++++++++++++++++++++++something and lol &emsp;只是通过其中简单的代表性API展示reflect的应用，详细的api可以去reflect包中阅读源码，不难看出，Java反射中的构造函数，属性，方法有着诸多相似之处，不仅仅是因为它们有着共同的父类AccessibleObject，基本上所有的api都有相似之处，这里不做讨论。&emsp;通过这个简单例子还是比较好理解的，我们通过包名来获得这个类，再通过参数不同获得构造器，以及名字和参数类型去获得属性和方法。让人意外的是getDeclaredField居然可以不通过get方法去获得类的private属性，这个在spring的@Autowired注入里面相信大家都见到过。 个人总结&emsp;很多开源框架例如Spring、MyBatis、Hibernate, 都已使用到了java的反射技术作为整个框架的基础。因为方便的原因，大家都习惯地使用注解去完成一些变量对象的注入，其实最为基础的写法是在xml等配置文件去书写，例如Spring的bean、MyBatis的Mapper。有的人觉得配置文件很繁琐，不如全用java代码去实现多好。&emsp;配置文件的作用在于，如果需求发生变动或者代码需要修改时，必须在java类里去修改，然后再去重新编译，但是对于大型的项目来说重新编译的代价可能比较高。而通过配置文件来实现的话，每次修改只需要在配置文件里去修改就好了，因为配置文件属于静态资源，无需重新编译代码，这无疑降低了成本，大大减少了代码的耦合。代码配置分离，无论是复用性还是灵活性都大大地提高了。&emsp;这就是我在大作业里选择了Mybatis而不是Hibernate的原因之一，虽然学要写的东西多了，但是没有把代码写死，灵活性大大提高，后期修改维护也变得容易多了。 &emsp;Reflect机制也不是完美的，灵活性的同时也违背了Java引以为傲的面向对象的封装性，使用时更应注意扬长避短。","link":"/2019/03/26/J2ee-pattern-1/"}],"tags":[{"name":"笔试","slug":"笔试","link":"/tags/笔试/"},{"name":"面试","slug":"面试","link":"/tags/面试/"},{"name":"前端","slug":"前端","link":"/tags/前端/"},{"name":"算法","slug":"算法","link":"/tags/算法/"},{"name":"字节跳动","slug":"字节跳动","link":"/tags/字节跳动/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"箭头函数","slug":"箭头函数","link":"/tags/箭头函数/"},{"name":"visitor","slug":"visitor","link":"/tags/visitor/"},{"name":"人工智能","slug":"人工智能","link":"/tags/人工智能/"},{"name":"机器学习","slug":"机器学习","link":"/tags/机器学习/"},{"name":"深度学习","slug":"深度学习","link":"/tags/深度学习/"},{"name":"反射机制","slug":"反射机制","link":"/tags/反射机制/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"}],"categories":[{"name":"Interviews","slug":"Interviews","link":"/categories/Interviews/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","link":"/categories/Artificial-Intelligence/"},{"name":"ES6","slug":"JavaScript/ES6","link":"/categories/JavaScript/ES6/"},{"name":"Desgin Patterns","slug":"Java/Desgin-Patterns","link":"/categories/Java/Desgin-Patterns/"},{"name":"J2EE","slug":"Java/J2EE","link":"/categories/Java/J2EE/"}]}