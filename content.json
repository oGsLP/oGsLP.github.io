{"pages":[{"title":"分类","text":"","link":"/categories/index.html"}],"posts":[{"title":"字节跳动暑期前端实习笔试 + 一面","text":"上周抱着试一试的心理去参加了班群里内推的字节跳动的暑期前端实习，笔试是在牛客网上做四道算法题，2个小时，前两题很简单做了30分钟就跑过了，后两道题难度有点大，我又是算法没怎么做过，所以光靠脑子还是有点招架不住。不知道是报的前端的原因还是后面两道的确难，也是拿到了面试资格，今天下午3点去试了一下，也是自己第一次求职面试。之前一直在赶大作业，所以就昨天晚上今天早上各两三个小时准备了一点，虽然面试题目其实不是很难但是还是倒了，而且是刚结束一分钟就收到短信说你凉了。。。分享一下，菜勿喷。 笔试 1024元的钞票买n ([0-1024]) 元的商品，共有64,16,4,1这四种硬币，问最少能找零几个硬币。 + 硬币币值差4倍相当于&gt;&gt;2，用移位来做 字符串问题，碰到aabb简化为aab，aaa简化为aa + charAt遍历，分情况讨论，每次简化时记得字符串长度会变 一个数组int[n]代表n个人的分数，n个人围成环，给他们发奖品，每个人至少一个，如果比左右分高，那么奖品也要比左右多，问最少发多少奖品，其中存在 1,2,3,3发奖品为1,2,3,2的情况 + 据说是动态规划的题目，自己不是很了解，记得填坑 一个数组int[n]代表n个绳子的长度，然后告诉你需要的绳子个数num，剪绳子但不能拼接，要求剪出来的绳子长度一样，其中num可能大于或等于或小于n，求剪出来的绳子最长长度是多少（保留2位小数）。 + 一开始当做数学提来写的，但是分情况很细的时候发现不太好讨论了，比如1,1,1,1,100要10根，我更本就不用考虑长度为1的，100分成10*10就完事了。其实可能还是要分解问题去做。。待填坑 我觉得无论如何前两题都得做出来，后两题真的需要大量的练习才能了解解题的技巧，光靠脑子是不行的，还是得加油啊 面试 平时以为自己前端写的还可以，面试问题就全暴露出来了，一堆基础知识掌握不牢，光靠临时抱佛脚还是不行的，js博大精深hhh，还是把我记得的都说出来看看 自我介绍一分钟左右，按照网上说的来历学历项目经验说一说吧，感觉他只对你的项目经验有一点兴趣。 html h5新特性（新标签）=&gt; 新标签的作用用法 css display,position的种类 =&gt; absolute,float导致的流出现覆盖的消除方法 一个定宽高以及不定宽高的块级元素水平居中的方法（margin auto left/right 0 ,flex等） 选择器的优先级 js 一上来问熟悉不熟悉 es2015 基本类型: boolean,string,number,undefined,null。 “还有?” ？？？？ “es15还有symbol” —es15还是很多东西不会的啊 编程题 找出字符串中出现最多的字母以及次数，我的天我居然忘了hash，用数组了。。。。 读程序输出题 我是真的懵逼了。。原型我是真的不会prototype1234567891011121314151617181920212223242526272829var A = function () { function B () { console.log(1); } return this;};A.B=function () { console.log(2);};A.prototype.B=function () { console.log(3);};var B = function () { console.log(4);};B = function () { console.log(5);};A().B;B();A.B();B();new A.B();new A().B(); is not a function;5;2;5;2;3 这题不会真的是js的基本功不行。。加上紧张诶，还是得回去还好练练 读程序setTimeOut123456for(var i = 0 ; i&lt;5 ;i++){ setTimeout(function () { console.log(i); });}console.log(i); 好不容易看到会的了，我一激动说成了一个0五个5，其实后来仔细一看是六个5。。。。 还问了怎么改，这个是会的，let、闭包立即函数 我只是个前端啊，没想到还问数据结构与算法。。。那些我学的都不行啊。。。 算法 冒泡排序bubbleSort123456789101112function bubbleSort(arr){ for(let i=0;i&lt;arr.length-1;i++){ for(let j=0;j&lt;arr.length-1-i;j++){ if(arr[j]&gt;arr[j+1]){ let temp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; } } } return arr;} 快速排序quickSort12345678910111213141516function quickSort(arr){ if(arr.length&lt;=1){return arr;} let pivotIndex=Math.floor(arr.length/2); let pivot=arr.splice(pivotIndex,1)[0]; let left=[]; let right=[]; for(let i=0;i&lt;arr.length;i++){ if(arr[i]&lt;=pivot){ left.push(arr[i]); } else{ right.push(arr[i]); } } return quickSort(left).concat([pivot],quickSort(right));} 这两个特地看了一下，还是会的 数据结构 二叉树我把前中后的顺序记错了。。面试官告诉我顺序还是能弄出来的 队列和栈的区别 我瞎答得，我记得队列先进先出，栈是先进后出 计算机网络 tcp、udp区别 三次握手，四次挥手 1-5的状态码。。细的我记不太清楚了 FAQ最后让我问他一些问题，我其实也没啥好问的，就问了这个工作的一些内容，草草收场了 最后 面试完如释重负，瞬间轻松好多，刚和舍友吐槽一下，叮~，一条短信，“经过慎重考虑，很遗憾你未通过此次面试，如果。。。。。。。。。。。。。。。。。。。。。。。。。。” 加油吧，学习吧，面试什么的下次再战！","link":"/2019/03/23/interview/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/03/12/hello-world/"},{"title":"ES6--箭头函数","text":"&emsp;刚把jee的大作业写完，其中前端用到了Vue框架，在官方文档和很多教程里都使用了许多箭头函数等es6特性，加之昨天面试字节跳动前端实习的时候问道js的第一句话就是“你了解es2015”吗。写项目的时候模仿去写但是好像上下文this和普通的函数不太一样，后来查文档学习了一下，但还是没有全部理解，现在准备系统地学习一下es6的特性，那么就先从箭头函数开始吧 基本语法12345678910111213141516(aruguments) =&gt; {statements}x =&gt; x+2 // 单参省略括号，单语句且为返回值省略大括号()=&gt;{} // 无参保留()*********************************************//加括号的函数体返回对象字面表达式：参数=&gt; ({foo: bar})//支持剩余参数和默认参数(参数1, 参数2, ...rest) =&gt; {函数声明}(参数1 = 默认值1,参数2, …, 参数N = 默认值N) =&gt; {函数声明}//同样支持参数列表解构let f = ([a, b] = [1, 2], {x: c} = {x: a + b}) =&gt; a + b + c;f(); // 6 官网对与箭头函数的描述有两个特点，一个是更简短，另一个则是不绑定this，举例来说明123456function Test(){ this.val = 0; setInterval(function test(){ this.val++; },1000);} &emsp;因为setInterval中的function的this上下文是全局对象，所以test里的this.val和对象的val不一样，一般采用bind(this)或者self/that=this,在setInterval中调用that来获得对象上下文，而箭头函数则是不绑定this，具体原因是因为箭头函数没有prototype，它只会从自己的作用域链的上一层继承this上下文，如下123456function Test(){ this.val = 0; setInterval(()=&gt;{ this.val++; },1000);} &emsp;如果拿我自己的大作业的例子来说就是在尝试promise、then的时候发现this上下文的问题，一开始用bind来解决，后来接触箭头函数，就直接用箭头函数改写了方法，但是当时不知道箭头函数的this直接继承，后来发现，觉得真的很方便，简化了繁琐的bind，直接上实际例子。123456789101112131415161718192021222324252627282930//改造前pay_deal(){ new Promise(function (resolve) { // 略 resolve(val_1); }.bind(this)) .then(function (val_1){ return new Promise(function (resolve) { // 略 resolve(val_2); }.bind(this)); }.bind(this)) .then(function (val_2) { // 略 }.bind(this));},//改造后pay_deal(){ new Promise(resolve =&gt; { // 略 resolve(val_1) }); }).then(val_1=&gt;new Promise(resolve =&gt; { // 略 resolve(val_2) } })).then(val_2=&gt;{ // 略 });}, &emsp;效果很明显，省去了繁琐的this绑定，特别在promise的then连写的时候，return new promise需要两次绑定，简直就是灾难，用箭头函数瞬间清爽了很多。 FAQ &emsp; 若是箭头函数的外层没有普通函数呢？ 普通函数的默认绑定规则是，非严格模式下this指向全局，严格模式下为undefined 箭头函数在全局作用域下，严格模式与非严格模式下都会指向window(全局对象) 以上是箭头函数基本的两个概念，也是最简单的应用，还有很多实际的复杂情况和别的技术混合使用的例子 apply/call调用&emsp;由于箭头函数没有自己的this，通过apply或者call调用的时候只能传递参数，而第一个参数–上下文将被忽略，同样，箭头函数调用bind也是徒劳之举，webstorm会直接提醒错误 1234567891011121314151617181920var adder = { base : 1, add : function(a) { var f = v =&gt; v + this.base; return f(a); }, addThruCall: function(a) { var f = v =&gt; v + this.base; var b = { base : 2 }; return f.call(b, a); }};console.log(adder.add(1)); // 输出 2console.log(adder.addThruCall(1)); // 仍然输出 2（而不是3 ——译者注） 参数调用&emsp;箭头函数同样不绑定arguments参数，若是全局下的箭头函数，arguments指向全局，会出现arguments未声明的错误。而当箭头函数的this指向普通函数时，它的arguments同样继承自普通函数，这点还是很好理解的，也是可以利用这个特性去处理外层函数的不定参数。&emsp;但是如果需要获得箭头函数的不定量参数呢，没有了arguments怎么做？这就要用到es6的另一个特性，rest参数(…扩展符)。 1234567let fun = (x, ...args)=&gt;{ console.log(x); console.log(args);};fun(1,2,3);// 1// [2,3] &emsp;rest参数的详细会再出一个文章介绍，现在大致先了解一下，rest和arguments的区别在于rest是一个真正的数组，可以使用数组的api。rest在普通函数和箭头函数中都可以使用，但必须作为函数参数的最后一位，剩余参数嘛，字面意思也可以理解。 其他 箭头函数不能使用构造器，使用new会报错 箭头函数没有prototype new.target指向外层函数的引用 箭头函数不支持重命名函数参数，而不同函数的重复参数后面的会覆盖前面的 注意事项 一条语句返回对象字面量，需要加括号或者直接写成多条语句的return形式。说到这里我好像明白了vue的比较新的版本里data都是return一个对象了，而不是直接写，一个就是这个原因吧，可能vue的解析将其作为箭头函数了 12345data:{ return{ foo: bar }} 箭头函数的参数和箭头之间不能换行 123let fun = () =&gt; 1// 报错 箭头函数的解析顺序相对靠前，虽然箭头不是运算符，但是箭头函数具有与常规函数不同的特殊运算符优先级解析规则。 12let bool = false || ()=&gt;true;// 箭头函数先执行，false则因为懒惰机制不会参与计算 使用&emsp;箭头函数在一些简单的运算处理中是很方便简洁的，但是在复杂的逻辑以及多重嵌套里，因为上下文的确定有一定难度，造成代码可读性差。一句话来说就是，箭头函数更适合非方法的函数，或者本来就是需要作为匿名函数的地方，因为箭头函数也是匿名函数。 &emsp;关于箭头函数的使用仁者见仁，智者见智，箭头函数也是一把双刃剑，用在恰当的地方就像庖丁解牛一样游刃有余，滥用则会造成许多不必要的问题。如何使用的最佳实践，还是需要在代码中不断尝试才能知道。","link":"/2019/03/24/arrow-function/"}],"tags":[{"name":"笔试","slug":"笔试","link":"/tags/笔试/"},{"name":"面试","slug":"面试","link":"/tags/面试/"},{"name":"前端","slug":"前端","link":"/tags/前端/"},{"name":"算法","slug":"算法","link":"/tags/算法/"},{"name":"字节跳动","slug":"字节跳动","link":"/tags/字节跳动/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"箭头函数","slug":"箭头函数","link":"/tags/箭头函数/"}],"categories":[{"name":"Interviews","slug":"Interviews","link":"/categories/Interviews/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"ES6","slug":"JavaScript/ES6","link":"/categories/JavaScript/ES6/"}]}