{"pages":[{"title":"分类","text":"","link":"/categories/index.html"}],"posts":[{"title":"ES6--箭头函数","text":"&emsp;刚把jee的大作业写完，其中前端用到了Vue框架，在官方文档和很多教程里都使用了许多箭头函数等es6特性，加之昨天面试字节跳动前端实习的时候问道js的第一句话就是“你了解es2015”吗。写项目的时候模仿去写但是好像上下文this和普通的函数不太一样，后来查文档学习了一下，但还是没有全部理解，现在准备系统地学习一下es6的特性，那么就先从箭头函数开始吧 基本语法12345678910111213141516(aruguments) =&gt; {statements}x =&gt; x+2 // 单参省略括号，单语句且为返回值省略大括号()=&gt;{} // 无参保留()*********************************************//加括号的函数体返回对象字面表达式：参数=&gt; ({foo: bar})//支持剩余参数和默认参数(参数1, 参数2, ...rest) =&gt; {函数声明}(参数1 = 默认值1,参数2, …, 参数N = 默认值N) =&gt; {函数声明}//同样支持参数列表解构let f = ([a, b] = [1, 2], {x: c} = {x: a + b}) =&gt; a + b + c;f(); // 6 官网对与箭头函数的描述有两个特点，一个是更简短，另一个则是不绑定this，举例来说明123456function Test(){ this.val = 0; setInterval(function test(){ this.val++; },1000);} &emsp;因为setInterval中的function的this上下文是全局对象，所以test里的this.val和对象的val不一样，一般采用bind(this)或者self/that=this,在setInterval中调用that来获得对象上下文，而箭头函数则是不绑定this，具体原因是因为箭头函数没有prototype，它只会从自己的作用域链的上一层继承this上下文，如下123456function Test(){ this.val = 0; setInterval(()=&gt;{ this.val++; },1000);} &emsp;如果拿我自己的大作业的例子来说就是在尝试promise、then的时候发现this上下文的问题，一开始用bind来解决，后来接触箭头函数，就直接用箭头函数改写了方法，但是当时不知道箭头函数的this直接继承，后来发现，觉得真的很方便，简化了繁琐的bind，直接上实际例子。123456789101112131415161718192021222324252627282930//改造前pay_deal(){ new Promise(function (resolve) { // 略 resolve(val_1); }.bind(this)) .then(function (val_1){ return new Promise(function (resolve) { // 略 resolve(val_2); }.bind(this)); }.bind(this)) .then(function (val_2) { // 略 }.bind(this));},//改造后pay_deal(){ new Promise(resolve =&gt; { // 略 resolve(val_1) }); }).then(val_1=&gt;new Promise(resolve =&gt; { // 略 resolve(val_2) } })).then(val_2=&gt;{ // 略 });}, &emsp;效果很明显，省去了繁琐的this绑定，特别在promise的then连写的时候，return new promise需要两次绑定，简直就是灾难，用箭头函数瞬间清爽了很多。 FAQ &emsp; 若是箭头函数的外层没有普通函数呢？ 普通函数的默认绑定规则是，非严格模式下this指向全局，严格模式下为undefined 箭头函数在全局作用域下，严格模式与非严格模式下都会指向window(全局对象) 以上是箭头函数基本的两个概念，也是最简单的应用，还有很多实际的复杂情况和别的技术混合使用的例子 apply/call调用&emsp;由于箭头函数没有自己的this，通过apply或者call调用的时候只能传递参数，而第一个参数–上下文将被忽略，同样，箭头函数调用bind也是徒劳之举，webstorm会直接提醒错误 1234567891011121314151617181920var adder = { base : 1, add : function(a) { var f = v =&gt; v + this.base; return f(a); }, addThruCall: function(a) { var f = v =&gt; v + this.base; var b = { base : 2 }; return f.call(b, a); }};console.log(adder.add(1)); // 输出 2console.log(adder.addThruCall(1)); // 仍然输出 2（而不是3 ——译者注） 参数调用&emsp;箭头函数同样不绑定arguments参数，若是全局下的箭头函数，arguments指向全局，会出现arguments未声明的错误。而当箭头函数的this指向普通函数时，它的arguments同样继承自普通函数，这点还是很好理解的，也是可以利用这个特性去处理外层函数的不定参数。&emsp;但是如果需要获得箭头函数的不定量参数呢，没有了arguments怎么做？这就要用到es6的另一个特性，rest参数(…扩展符)。 1234567let fun = (x, ...args)=&gt;{ console.log(x); console.log(args);};fun(1,2,3);// 1// [2,3] &emsp;rest参数的详细会再出一个文章介绍，现在大致先了解一下，rest和arguments的区别在于rest是一个真正的数组，可以使用数组的api。rest在普通函数和箭头函数中都可以使用，但必须作为函数参数的最后一位，剩余参数嘛，字面意思也可以理解。 其他 箭头函数不能使用构造器，使用new会报错 箭头函数没有prototype new.target指向外层函数的引用 箭头函数不支持重命名函数参数，而不同函数的重复参数后面的会覆盖前面的 注意事项 一条语句返回对象字面量，需要加括号或者直接写成多条语句的return形式。说到这里我好像明白了vue的比较新的版本里data都是return一个对象了，而不是直接写，一个就是这个原因吧，可能vue的解析将其作为箭头函数了 12345data:{ return{ foo: bar }} 箭头函数的参数和箭头之间不能换行 123let fun = () =&gt; 1// 报错 箭头函数的解析顺序相对靠前，虽然箭头不是运算符，但是箭头函数具有与常规函数不同的特殊运算符优先级解析规则。 12let bool = false || ()=&gt;true;// 箭头函数先执行，false则因为懒惰机制不会参与计算 使用&emsp;箭头函数在一些简单的运算处理中是很方便简洁的，但是在复杂的逻辑以及多重嵌套里，因为上下文的确定有一定难度，造成代码可读性差。一句话来说就是，箭头函数更适合非方法的函数，或者本来就是需要作为匿名函数的地方，因为箭头函数也是匿名函数。 &emsp;关于箭头函数的使用仁者见仁，智者见智，箭头函数也是一把双刃剑，用在恰当的地方就像庖丁解牛一样游刃有余，滥用则会造成许多不必要的问题。如何使用的最佳实践，还是需要在代码中不断尝试才能知道。","link":"/2019/03/24/arrow-function/"},{"title":"字节跳动暑期前端实习笔试 + 一面","text":"上周抱着试一试的心理去参加了班群里内推的字节跳动的暑期前端实习，笔试是在牛客网上做四道算法题，2个小时，前两题很简单做了30分钟就跑过了，后两道题难度有点大，我又是算法没怎么做过，所以光靠脑子还是有点招架不住。不知道是报的前端的原因还是后面两道的确难，也是拿到了面试资格，今天下午3点去试了一下，也是自己第一次求职面试。之前一直在赶大作业，所以就昨天晚上今天早上各两三个小时准备了一点，虽然面试题目其实不是很难但是还是倒了，而且是刚结束一分钟就收到短信说你凉了。。。分享一下，菜勿喷。 笔试 1024元的钞票买n ([0-1024]) 元的商品，共有64,16,4,1这四种硬币，问最少能找零几个硬币。 + 硬币币值差4倍相当于&gt;&gt;2，用移位来做 字符串问题，碰到aabb简化为aab，aaa简化为aa + charAt遍历，分情况讨论，每次简化时记得字符串长度会变 一个数组int[n]代表n个人的分数，n个人围成环，给他们发奖品，每个人至少一个，如果比左右分高，那么奖品也要比左右多，问最少发多少奖品，其中存在 1,2,3,3发奖品为1,2,3,2的情况 + 据说是动态规划的题目，自己不是很了解，记得填坑 一个数组int[n]代表n个绳子的长度，然后告诉你需要的绳子个数num，剪绳子但不能拼接，要求剪出来的绳子长度一样，其中num可能大于或等于或小于n，求剪出来的绳子最长长度是多少（保留2位小数）。 + 一开始当做数学提来写的，但是分情况很细的时候发现不太好讨论了，比如1,1,1,1,100要10根，我更本就不用考虑长度为1的，100分成10*10就完事了。其实可能还是要分解问题去做。。待填坑 我觉得无论如何前两题都得做出来，后两题真的需要大量的练习才能了解解题的技巧，光靠脑子是不行的，还是得加油啊 面试 平时以为自己前端写的还可以，面试问题就全暴露出来了，一堆基础知识掌握不牢，光靠临时抱佛脚还是不行的，js博大精深hhh，还是把我记得的都说出来看看 自我介绍一分钟左右，按照网上说的来历学历项目经验说一说吧，感觉他只对你的项目经验有一点兴趣。 html h5新特性（新标签）=&gt; 新标签的作用用法 css display,position的种类 =&gt; absolute,float导致的流出现覆盖的消除方法 一个定宽高以及不定宽高的块级元素水平居中的方法（margin auto left/right 0 ,flex等） 选择器的优先级 js 一上来问熟悉不熟悉 es2015 基本类型: boolean,string,number,undefined,null。 “还有?” ？？？？ “es15还有symbol” —es15还是很多东西不会的啊 编程题 找出字符串中出现最多的字母以及次数，我的天我居然忘了hash，用数组了。。。。 读程序输出题 我是真的懵逼了。。原型我是真的不会prototype1234567891011121314151617181920212223242526272829var A = function () { function B () { console.log(1); } return this;};A.B=function () { console.log(2);};A.prototype.B=function () { console.log(3);};var B = function () { console.log(4);};B = function () { console.log(5);};A().B;B();A.B();B();new A.B();new A().B(); is not a function;5;2;5;2;3 这题不会真的是js的基本功不行。。加上紧张诶，还是得回去还好练练 读程序setTimeOut123456for(var i = 0 ; i&lt;5 ;i++){ setTimeout(function () { console.log(i); });}console.log(i); 好不容易看到会的了，我一激动说成了一个0五个5，其实后来仔细一看是六个5。。。。 还问了怎么改，这个是会的，let、闭包立即函数 我只是个前端啊，没想到还问数据结构与算法。。。那些我学的都不行啊。。。 算法 冒泡排序bubbleSort123456789101112function bubbleSort(arr){ for(let i=0;i&lt;arr.length-1;i++){ for(let j=0;j&lt;arr.length-1-i;j++){ if(arr[j]&gt;arr[j+1]){ let temp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; } } } return arr;} 快速排序quickSort12345678910111213141516function quickSort(arr){ if(arr.length&lt;=1){return arr;} let pivotIndex=Math.floor(arr.length/2); let pivot=arr.splice(pivotIndex,1)[0]; let left=[]; let right=[]; for(let i=0;i&lt;arr.length;i++){ if(arr[i]&lt;=pivot){ left.push(arr[i]); } else{ right.push(arr[i]); } } return quickSort(left).concat([pivot],quickSort(right));} 这两个特地看了一下，还是会的 数据结构 二叉树我把前中后的顺序记错了。。面试官告诉我顺序还是能弄出来的 队列和栈的区别 我瞎答得，我记得队列先进先出，栈是先进后出 计算机网络 tcp、udp区别 三次握手，四次挥手 1-5的状态码。。细的我记不太清楚了 FAQ最后让我问他一些问题，我其实也没啥好问的，就问了这个工作的一些内容，草草收场了 最后 面试完如释重负，瞬间轻松好多，刚和舍友吐槽一下，叮~，一条短信，“经过慎重考虑，很遗憾你未通过此次面试，如果。。。。。。。。。。。。。。。。。。。。。。。。。。” 加油吧，学习吧，面试什么的下次再战！","link":"/2019/03/23/interview/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/03/12/hello-world/"},{"title":"ES6--模板字符串","text":"&emsp;软工三的时候大作业都采用了原生的一些方法，很多时候会碰到字符串里面引号错乱很头疼的时候，包括获得request的内容也是在jsp中嵌入java代码再转成js对象。j2ee的大作业接触了更多的技术后才发现嵌入代码或者数据的好处，例如jsp中使用el表达式，mustache语法在themeleaf和vue,angular等中的运用。其中还是js的es6新特性模板字符串让我最为欣赏。 模板字符串&emsp;其实原生的js里就有模板字符串的运用了，特别是在js操作新建dom的时候，例如123456$('#result').append( 'There are &lt;b&gt;' + basket.count + '&lt;/b&gt; ' + 'items in your basket, ' + '&lt;em&gt;' + basket.onSale + '&lt;/em&gt; are on sale!'); &emsp;这样的话要写很多的+和’’以及””,特别是嵌套的时候会出现各种复杂的问题，让人很难受，新的模板字符串特性使用反向引号和${}来完成字符串的拼接组成。12345$('#result').append(` There are &lt;b&gt;${basket.count}&lt;/b&gt; items in your basket, &lt;em&gt;${basket.onSale}&lt;/em&gt; are on sale!`); &emsp;少了很多引号和加号，瞬间会清爽很多吧。&emsp;写大作业的时候第一次了解到这个的时候瞬间有一种亲切感，那是因为不是第一次接触这个了，在自己学习perl的时候也碰到了几乎一样的定义，这比java繁琐的字符串操作要方便多了。有了这个，写大作业的时候可以说是游刃有余，特别在axios请求的url中需要一些动态生成的值，直接使用`/api/member/${member_id}`就行了。 其他&emsp;其实模板字符串并没有太多的内容，以上基本就是所有用法了，还有以下一些注意事项。 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。 大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性，而且还能调用函数(这点和vue使用的mustache语法很像) 如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。 模板字符串甚至还能嵌套。 1234567891011121314151617181920212223const tmpl = addrs =&gt; ` &lt;table&gt; ${addrs.map(addr =&gt; ` &lt;tr&gt;&lt;td&gt;${addr.first}&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;${addr.last}&lt;/td&gt;&lt;/tr&gt; `).join('')} &lt;/table&gt;`;const data = [ { first: '&lt;Jane&gt;', last: 'Bond' }, { first: 'Lars', last: '&lt;Croft&gt;' },];console.log(tmpl(data));// &lt;table&gt;//// &lt;tr&gt;&lt;td&gt;&lt;Jane&gt;&lt;/td&gt;&lt;/tr&gt;// &lt;tr&gt;&lt;td&gt;Bond&lt;/td&gt;&lt;/tr&gt;//// &lt;tr&gt;&lt;td&gt;Lars&lt;/td&gt;&lt;/tr&gt;// &lt;tr&gt;&lt;td&gt;&lt;Croft&gt;&lt;/td&gt;&lt;/tr&gt;//// &lt;/table&gt; 可以引用模板字符串本身执行 123456789// 写法一let str = 'return ' + '`Hello ${name}!`';let func = new Function('name', str);func('Jack') // \"Hello Jack!\"// 写法二let str = '(name) =&gt; `Hello ${name}!`';let func = eval.call(null, str);func('Jack') // \"Hello Jack!\" 应用&emsp;配合正则表达式等，模板字符串还有一些实用的技巧 摘自阮一峰老师的es6教程下面，我们来看一个通过模板字符串，生成正式模板的实例。 1234567let template = `&lt;ul&gt; &lt;% for(let i=0; i &lt; data.supplies.length; i++) { %&gt; &lt;li&gt;&lt;%= data.supplies[i] %&gt;&lt;/li&gt; &lt;% } %&gt;&lt;/ul&gt;`; 上面代码在模板字符串之中，放置了一个常规模板。该模板使用&lt;%...%&gt;放置 JavaScript 代码，使用&lt;%= ... %&gt;输出 JavaScript 表达式。 怎么编译这个模板字符串呢？ 一种思路是将其转换为 JavaScript 表达式字符串。 1234567echo('&lt;ul&gt;');for(let i=0; i &lt; data.supplies.length; i++) { echo('&lt;li&gt;'); echo(data.supplies[i]); echo('&lt;/li&gt;');};echo('&lt;/ul&gt;'); 这个转换使用正则表达式就行了。 12345678let evalExpr = /&lt;%=(.+?)%&gt;/g;let expr = /&lt;%([\\s\\S]+?)%&gt;/g;template = template .replace(evalExpr, '`); \\n echo( $1 ); \\n echo(`') .replace(expr, '`); \\n $1 \\n echo(`');template = 'echo(`' + template + '`);'; 然后，将template封装在一个函数里面返回，就可以了。 1234567891011121314let script =`(function parse(data){ let output = \"\"; function echo(html){ output += html; } ${ template } return output;})`;return script; 将上面的内容拼装成一个模板编译函数compile。 12345678910111213141516171819202122232425function compile(template){ const evalExpr = /&lt;%=(.+?)%&gt;/g; const expr = /&lt;%([\\s\\S]+?)%&gt;/g; template = template .replace(evalExpr, '`); \\n echo( $1 ); \\n echo(`') .replace(expr, '`); \\n $1 \\n echo(`'); template = 'echo(`' + template + '`);'; let script = `(function parse(data){ let output = \"\"; function echo(html){ output += html; } ${ template } return output; })`; return script;} compile函数的用法如下。 1234567let parse = eval(compile(template));div.innerHTML = parse({ supplies: [ \"broom\", \"mop\", \"cleaner\" ] });// &lt;ul&gt;// &lt;li&gt;broom&lt;/li&gt;// &lt;li&gt;mop&lt;/li&gt;// &lt;li&gt;cleaner&lt;/li&gt;// &lt;/ul&gt; 标签模板模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。 123alert`123`// 等同于alert(123) 标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。 但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。 123456let a = 5;let b = 10;tag`Hello ${ a + b } world ${ a * b }`;// 等同于tag(['Hello ', ' world ', ''], 15, 50); 上面代码中，模板字符串前面有一个标识名tag，它是一个函数。整个表达式的返回值，就是tag函数处理模板字符串后的返回值。 函数tag依次会接收到多个参数。 123456789function tag(stringArr, value1, value2){ // ...}// 等同于function tag(stringArr, ...values){ // ...} tag函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。 tag函数的其他参数，都是模板字符串各个变量被替换后的值。由于本例中，模板字符串含有两个变量，因此tag会接受到value1和value2两个参数。 tag函数所有参数的实际值如下。 第一个参数：['Hello ', ' world ', ''] 第二个参数: 15 第三个参数：50 也就是说，tag函数实际上以下面的形式调用。 1tag(['Hello ', ' world ', ''], 15, 50) 我们可以按照需要编写tag函数的代码。下面是tag函数的一种写法，以及运行结果。 1234567891011121314151617181920let a = 5;let b = 10;function tag(s, v1, v2) { console.log(s[0]); console.log(s[1]); console.log(s[2]); console.log(v1); console.log(v2); return \"OK\";}tag`Hello ${ a + b } world ${ a * b}`;// \"Hello \"// \" world \"// \"\"// 15// 50// \"OK\" 下面是一个更复杂的例子。 123456789101112131415161718let total = 30;let msg = passthru`The total is ${total} (${total*1.05} with tax)`;function passthru(literals) { let result = ''; let i = 0; while (i &lt; literals.length) { result += literals[i++]; if (i &lt; arguments.length) { result += arguments[i]; } } return result;}msg // \"The total is 30 (31.5 with tax)\" 上面这个例子展示了，如何将各个参数按照原来的位置拼合回去。 passthru函数采用 rest 参数的写法如下。 12345678910function passthru(literals, ...values) { let output = \"\"; let index; for (index = 0; index &lt; values.length; index++) { output += literals[index] + values[index]; } output += literals[index] return output;} “标签模板”的一个重要应用，就是过滤 HTML 字符串，防止用户输入恶意内容。 123456789101112131415161718let message = SaferHTML`&lt;p&gt;${sender} has sent you a message.&lt;/p&gt;`;function SaferHTML(templateData) { let s = templateData[0]; for (let i = 1; i &lt; arguments.length; i++) { let arg = String(arguments[i]); // Escape special characters in the substitution. s += arg.replace(/&amp;/g, \"&amp;amp;\") .replace(/&lt;/g, \"&amp;lt;\") .replace(/&gt;/g, \"&amp;gt;\"); // Don't escape special characters in the template. s += templateData[i]; } return s;} 上面代码中，sender变量往往是用户提供的，经过SaferHTML函数处理，里面的特殊字符都会被转义。 12345let sender = '&lt;script&gt;alert(\"abc\")&lt;/script&gt;'; // 恶意代码let message = SaferHTML`&lt;p&gt;${sender} has sent you a message.&lt;/p&gt;`;message// &lt;p&gt;&amp;lt;script&amp;gt;alert(\"abc\")&amp;lt;/script&amp;gt; has sent you a message.&lt;/p&gt; 标签模板的另一个应用，就是多语言转换（国际化处理）。 12i18n`Welcome to ${siteName}, you are visitor number ${visitorNumber}!`// \"欢迎访问xxx，您是第xxxx位访问者！\" 模板字符串本身并不能取代 Mustache 之类的模板库，因为没有条件判断和循环处理功能，但是通过标签函数，你可以自己添加这些功能。 123456789// 下面的hashTemplate函数// 是一个自定义的模板处理函数let libraryHtml = hashTemplate` &lt;ul&gt; #for book in ${myBooks} &lt;li&gt;&lt;i&gt;#{book.title}&lt;/i&gt; by #{book.author}&lt;/li&gt; #end &lt;/ul&gt;`; 除此之外，你甚至可以使用标签模板，在 JavaScript 语言之中嵌入其他语言。 123456789jsx` &lt;div&gt; &lt;input ref='input' onChange='${this.handleChange}' defaultValue='${this.state.value}' /&gt; ${this.state.value} &lt;/div&gt;` 上面的代码通过jsx函数，将一个 DOM 字符串转为 React 对象。你可以在 GitHub 找到jsx函数的具体实现。 下面则是一个假想的例子，通过java函数，在 JavaScript 代码之中运行 Java 代码。 12345678java`class HelloWorldApp { public static void main(String[] args) { System.out.println(\"Hello World!\"); // Display the string. }}`HelloWorldApp.main(); 模板处理函数的第一个参数（模板字符串数组），还有一个raw属性。 12console.log`123`// [\"123\", raw: Array[1]] 上面代码中，console.log接受的参数，实际上是一个数组。该数组有一个raw属性，保存的是转义后的原字符串。 请看下面的例子。 1234567tag`First line\\nSecond line`function tag(strings) { console.log(strings.raw[0]); // strings.raw[0] 为 \"First line\\\\nSecond line\" // 打印输出 \"First line\\nSecond line\"} 上面代码中，tag函数的第一个参数strings，有一个raw属性，也指向一个数组。该数组的成员与strings数组完全一致。比如，strings数组是[&quot;First line\\nSecond line&quot;]，那么strings.raw数组就是[&quot;First line\\\\nSecond line&quot;]。两者唯一的区别，就是字符串里面的斜杠都被转义了。比如，strings.raw 数组会将\\n视为\\\\和n两个字符，而不是换行符。这是为了方便取得转义之前的原始模板而设计的。","link":"/2019/03/24/template-string/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"箭头函数","slug":"箭头函数","link":"/tags/箭头函数/"},{"name":"笔试","slug":"笔试","link":"/tags/笔试/"},{"name":"面试","slug":"面试","link":"/tags/面试/"},{"name":"前端","slug":"前端","link":"/tags/前端/"},{"name":"算法","slug":"算法","link":"/tags/算法/"},{"name":"字节跳动","slug":"字节跳动","link":"/tags/字节跳动/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"Interviews","slug":"Interviews","link":"/categories/Interviews/"},{"name":"ES6","slug":"JavaScript/ES6","link":"/categories/JavaScript/ES6/"}]}